<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>Pr&aacute;ctica 3: Se&ntilde;ales en tiempo continuo</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-03-18">
<meta name="DC.source" content="untitled2.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>Pr&aacute;ctica 3: Se&ntilde;ales en tiempo continuo</h1>
<!--introduction-->
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Integrantes</a>
</li>
<li>
<a href="#2">Objetivos de la Pr&aacute;ctica</a>
</li>
<li>
<a href="#3">Introducci&oacute;n</a>
</li>
<li>
<a href="#5">Desarrollo</a>
</li>
<li>
<a href="#6">Problema 1</a>
</li>
<li>
<a href="#7">1.11 MATLAB: WORKING WITH FUNCTIONS</a>
</li>
<li>
<a href="#8">1.11-1 Anonymous Functions</a>
</li>
<li>
<a href="#25">1.11-2 Relational Operators and the Unit Step Function</a>
</li>
<li>
<a href="#34">1.11-3 Visualizaci&oacute;n de operaciones en la variable independiente</a>
</li>
<li>
<a href="#43">1.11-4 Numerical Integration and Estimating Signal Energy</a>
</li>
<li>
<a href="#59">1.12 SUMMARY</a>
</li>
<li>
<a href="#60">Problema 2</a>
</li>
<li>
<a href="#62">a) x(t-4)</a>
</li>
<li>
<a href="#64">b) x(t/1.5)</a>
</li>
<li>
<a href="#67">c)x(&minus;t)</a>
</li>
<li>
<a href="#70">d) x(2t &minus;4)</a>
</li>
<li>
<a href="#72">e) x(2&minus;t)</a>
</li>
<li>
<a href="#73">Problema 3</a>
</li>
<li>
<a href="#81">Problema 4</a>
</li>
<li>
<a href="#83">Problema 5</a>
</li>
<li>
<a href="#84">Problema 6</a>
</li>
<li>
<a href="#91">REFERENCIAS</a>
</li>
</ul>
</div>
<h2 id="1">Integrantes</h2>
<div>
<ul>
<li>Hernandez L&oacute;pez Daniel</li>
<li>Jaime Hern&aacute;ndez Jaime</li>
<li>Ojeda Salgado Rodrigo</li>
<li>Reyes Guevara Nathalia</li>
<li>Riveros Valencia Javier Alejandro</li>
</ul>
</div>
<h2 id="2">Objetivos de la Pr&aacute;ctica</h2>
<div>
<ul>
<li>Manipulaci&oacute;n b&aacute;sica de MATLAB</li>
<li>Gr&aacute;ficas de se&ntilde;ales reales y complejas continuas</li>
<li>Transformaci&oacute;n de se&ntilde;ales continuas (escalamientos y traslaciones)</li>
<li>Calculo de energ&iacute;a y potencia de se&ntilde;ales continuas</li>
</ul>
</div>
<h2 id="3">Introducci&oacute;n</h2>
<p>Como evidencia de la investigaci&ograve;n en Python se grafica lo siguiente:</p>
<p>
<img vspace="5" hspace="5" src="descarga.PNG" alt=""> </p>
<p>El codigo con el que se genero la grafica pues consultarse en este enlace <a href="https://colab.research.google.com/drive/12C3_0FH1c_eUslcJhYHQlChPufOYX8Cj?usp=sharing">https://colab.research.google.com/drive/12C3_0FH1c_eUslcJhYHQlChPufOYX8Cj?usp=sharing</a>
</p>
<h2 id="5">Desarrollo</h2>
<h2 id="6">Problema 1</h2>
<h2 id="7">1.11 MATLAB: WORKING WITH FUNCTIONS</h2>
<pre>El trabajo con funciones es fundamental para las aplicaciones de se&ntilde;ales y sistemas. MATLAB proporciona varios m&eacute;todos para definir y evaluar funciones. Por lo tanto, la comprensi&oacute;n y el uso competente de estos m&eacute;todos son necesarios y beneficiosos.</pre>
<h2 id="8">1.11-1 Anonymous Functions</h2>
<p>Muchas funciones sencillas se representan de forma m&aacute;s c&oacute;moda mediante el uso de MATLAB anonymous Funciones. Una funci&oacute;n an&oacute;nima proporciona una representaci&oacute;n simb&oacute;lica de una funci&oacute;n definida en t&eacute;rminos de operadores, funciones u otras funciones an&oacute;nimas de MATLAB. Por ejemplo, considere Definici&oacute;n de la sinusoide exponencialmente amortiguada f(t) = e&minus;t cos(2Ï€t)</p>
<pre class="codeinput"> f = @(t) exp(-t).*cos(2*pi*t) ;
</pre>
<p>En este contexto, el s&iacute;mbolo @ identifica la expresi&oacute;n como una funci&oacute;n an&oacute;nima, que se asigna un nombre de f. Los par&eacute;ntesis que siguen al s&iacute;mbolo @ se utilizan para identificar la funci&oacute;n independiente. variables (argumentos de entrada), que en este caso es la &uacute;nica variable de tiempo t. Argumentos de entrada, como como t, son locales de la funci&oacute;n an&oacute;nima y no est&aacute;n relacionados con ninguna variable del espacio de trabajo con la mismos nombres.</p>
<p>Una vez definida, f(t) se puede evaluar simplemente pasando los valores de entrada de inter&eacute;s. Para ejemplo,</p>
<pre class="codeinput"> t = 0; f(t)
</pre>
<pre class="codeoutput">
ans =

     1

</pre>
<p>ans = 1 eval&uacute;a f(t) en t = 0, confirmando el resultado esperado de la unidad. El mismo resultado se obtiene mediante pasando t = 0 directamente.</p>
<pre class="codeinput">f(0)
</pre>
<pre class="codeoutput">
ans =

     1

</pre>
<p>respuesta = 1 Las entradas vectoriales permiten la evaluaci&oacute;n de m&uacute;ltiples valores simult&aacute;neamente. Considere la tarea de trazar f(t) en el intervalo (&minus;2 &le; t &le; 2). El comportamiento de la funci&oacute;n bruta es claro: f(t) deber&iacute;a oscilar cuatro veces con una envolvente en decadencia. Dado que los bocetos precisos a mano son engorrosos, Los gr&aacute;ficos generados por MATLAB son una alternativa atractiva. Como ilustra el siguiente ejemplo, el cuidado Se deben tomar medidas para garantizar resultados confiables.</p>
<p>Supongamos que se elige el vector t para incluir solo los n&uacute;meros enteros contenidos en (&minus;2 &le; t &le; 2), es decir, [-2,-1, 0, 1, 2].</p>
<pre class="codeinput"> t = (-2:2);
</pre>
<p>Esta entrada vectorial se eval&uacute;a para formar una salida vectorial.</p>
<pre class="codeinput"> f(t)
</pre>
<pre class="codeoutput">
ans =

    7.3891    2.7183    1.0000    0.3679    0.1353

</pre>
<p>respuesta = 7,3891 2,7183 1,0000 0,3679 0,135</p>
<p>El comando plot grafica el resultado, que se muestra en la figura 1.46.</p>
<pre class="codeinput">plot(t,f(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'f(t)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="untitled2_01.png" alt=""> <p>Las l&iacute;neas de cuadr&iacute;cula, agregadas mediante el comando de cuadr&iacute;cula, ayudan a identificar las caracter&iacute;sticas. Desafortunadamente, el El gr&aacute;fico no ilustra el comportamiento oscilatorio esperado. Se requieren m&aacute;s puntos para adecuadamente representar f(t).</p>
<p>La pregunta entonces es &iquest;cu&aacute;ntos puntos son suficientes?&dagger; Si se eligen muy pocos puntos, la informaci&oacute;n est&aacute; perdido. Si se eligen demasiados puntos, se desperdicia memoria y tiempo. Se necesita un equilibrio. Para funciones oscilatorias, normalmente es adecuado trazar de 20 a 200 puntos por oscilaci&oacute;n. Para el presente En este caso, se elige t para dar 100 puntos por oscilaci&oacute;n.</p>
<pre class="codeinput">t = (-2:0.01:2);
</pre>
<p>Nuevamente, la funci&oacute;n se eval&uacute;a y traza:</p>
<pre class="codeinput">plot(t,f(t));
xlabel(<span class="string">'t&rsquo;); ylabel(&rsquo;f(t)'</span>); grid
</pre>
<img vspace="5" hspace="5" src="untitled2_02.png" alt=""> <h2 id="25">1.11-2 Relational Operators and the Unit Step Function</h2>
<p>La funci&oacute;n escal&oacute;n unitario u(t) surge naturalmente en muchas situaciones pr&aacute;cticas. Por ejemplo, un paso unitario puede Modelar el acto de encender un sistema. Con la ayuda de operadores relacionales, funciones an&oacute;nimas. puede representar la funci&oacute;n de paso unitario. En MATLAB, un operador relacional compara dos elementos. Si la comparaci&oacute;n es cierta, una verdad l&oacute;gica. (1) se devuelve. Si la comparaci&oacute;n es falsa, se devuelve un falso l&oacute;gico (0). A veces llamado indicador funciones, los operadores relacionales indican si una condici&oacute;n es verdadera. Seis operadores relacionales son disponibles: &lt;, &gt;, &lt;=, &gt;=, == y ~=. La funci&oacute;n de escal&oacute;n unitario se define f&aacute;cilmente usando el operador relacional &gt;=</p>
<pre class="codeinput">u = @(t) 1.0.*(t&gt;=0);
</pre>
<p>Cualquier funci&oacute;n con una discontinuidad de salto, como el escal&oacute;n unitario, es dif&iacute;cil de trazar. Considere la posibilidad de trazar u(t) usando t = (-2:2).</p>
<pre class="codeinput">t = (-2:2); plot(t,u(t));
xlabel(<span class="string">'t&rsquo;); ylabel(&rsquo;u(t)'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_03.png" alt=""> <p>Dos problemas importantes son evidentes en el gr&aacute;fico resultante, que se muestra en la figura 1.48. Primero, MATLAB escala autom&aacute;ticamente los ejes del gr&aacute;fico para vincular estrechamente los datos. En este caso, esto normalmente La caracter&iacute;stica deseable oscurece la mayor parte de la trama. En segundo lugar, MATLAB conecta los datos del trazado con l&iacute;neas, haciendo que una verdadera discontinuidad de salto sea dif&iacute;cil de lograr. La resoluci&oacute;n gruesa del vector t enfatiza el efecto al mostrar una l&iacute;nea inclinada err&oacute;nea entre t = &minus;1 y t = 0. El primer problema se corrige ampliando verticalmente el cuadro delimitador con el eje dominio. El segundo problema se reduce, pero no se elimina, sumando puntos al vector t.</p>
<pre class="codeinput">t = (-2:0.01:2); plot(t,u(t));
 xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'u(t)'</span>);
 axis([-2 2 -0.1 1.1]);
</pre>
<img vspace="5" hspace="5" src="untitled2_04.png" alt=""> <p>El argumento vectorial de cuatro elementos del eje especifica el eje x m&iacute;nimo, el eje x m&aacute;ximo y el eje y. m&iacute;nimo y m&aacute;ximo del eje y, respectivamente. Los resultados mejorados se muestran en la figura 1.49. Los operadores relacionales se pueden combinar usando AND l&oacute;gico, O l&oacute;gico y negaci&oacute;n l&oacute;gica: &amp;, | y ~, respectivamente. Por ejemplo, (t&gt;0)&amp;(t&lt;1) y ~((t&lt;=0)|(t&gt;=1)) prueban si 0 &lt; t &lt; 1. Para demostrarlo, considere definir y trazar el pulso unitario p(t) = u(t) &minus; u(t &minus; 1), como se muestra en Figura 1.50</p>
<pre class="codeinput"> p = @(t) 1.0.*((t&gt;=0)&amp;(t&lt;1));
t = (-1:0.01:2); plot(t,p(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'p(t) = u(t)-u(t-1)'</span>);
axis([-1 2 -.1 1.1]);
</pre>
<img vspace="5" hspace="5" src="untitled2_05.png" alt=""> <p>Dado que las funciones an&oacute;nimas se pueden construir utilizando otras funciones an&oacute;nimas, podr&iacute;amos Hemos utilizado nuestra funci&oacute;n an&oacute;nima de paso unitario previamente definida para definir p(t) como p = @(t) u(t)-u(t-1); Para operandos escalares, MATLAB tambi&eacute;n admite dos construcciones l&oacute;gicas de cortocircuito. A El AND l&oacute;gico de cortocircuito se realiza mediante &amp;&amp;, y el OR l&oacute;gico de cortocircuito se realiza mediante usando. Los operadores l&oacute;gicos de cortocircuito suelen ser m&aacute;s eficientes que los operadores l&oacute;gicos tradicionales. porque prueban la segunda parte de la expresi&oacute;n s&oacute;lo cuando es necesario. Es decir, cuando escalar la expresi&oacute;n A se encuentra falsa en (A&amp;&amp;B), la expresi&oacute;n escalar B no se eval&uacute;a, ya que un resultado falso ya est&aacute; garantizado. De manera similar, la expresi&oacute;n escalar B no se eval&uacute;a cuando la expresi&oacute;n escalar A es encontrado verdadero en (A||B), ya que ya se garantiza un resultado verdadero.</p>
<h2 id="34">1.11-3 Visualizaci&oacute;n de operaciones en la variable independiente</h2>
<p>Com&uacute;nmente se encuentran dos operaciones sobre la variable independiente de una funci&oacute;n: desplazamiento y escalada. Las funciones an&oacute;nimas son muy adecuadas para investigar ambas operaciones. Considere g(t) = f(t)u(t) = e&minus;t cos(2Ï€t)u(t), una versi&oacute;n causal de f(t). MATLAB f&aacute;cilmente multiplica funciones an&oacute;nimas. Por lo tanto, creamos g(t) multiplicando nuestras funciones an&oacute;nimas. para f(t) y u(t).</p>
<pre class="codeinput"> g = @(t) f(t).*u(t);
</pre>
<p>Una operaci&oacute;n combinada de cambio y escala est&aacute; representada por g(at + b), donde a y b son constantes reales arbitrarias. Como ejemplo, considere graficar g(2t +1) sobre (&minus;2 &le; t &le; 2). Con a = 2, la funci&oacute;n se comprime por un factor de 2, lo que da como resultado el doble de oscilaciones por unidad t. A&ntilde;adiendo la condici&oacute;n b &gt; 0 desplaza la forma de onda hacia la izquierda. Dada la funci&oacute;n an&oacute;nima g, una gr&aacute;fica precisa es casi trivial de obtener</p>
<pre class="codeinput"> t = (-2:0.01:2);
plot(t,g(2*t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'g(2t+1)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="untitled2_06.png" alt=""> <p>La Figura 1.51 confirma la compresi&oacute;n esperada de la forma de onda y el desplazamiento hacia la izquierda. Como comprobaci&oacute;n final, tenga en cuenta esa funci&oacute;n g(&middot;) se activa cuando el argumento de entrada es cero. Por lo tanto, g(2t + 1) deber&iacute;a activarse cuando 2t +1 = 0 o en t = &minus;0.5, hecho confirmado nuevamente por la figura 1.51. A continuaci&oacute;n, considere graficar g(&minus;t + 1) sobre (&minus;2 &le; t &le; 2). Como a &lt; 0, la forma de onda ser&aacute; reflejado. Agregar la condici&oacute;n b &gt; 0 desplaza la forma de onda final hacia la derecha.</p>
<pre class="codeinput">plot(t,g(-t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'g(-t+1)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="untitled2_07.png" alt=""> <p>La figura 1.52 confirma tanto la reflexi&oacute;n como el desplazamiento a la derecha. Hasta este punto, las Figs. 1,51 y 1,52 podr&iacute;an esbozarse razonablemente a mano. Considere la posibilidad de trazar la funci&oacute;n m&aacute;s complicada h(t) = g(2t + 1) + g(&minus;t + 1) sobre (&minus;2 &le; t &le; 2) (figura 1.53); un Un boceto a mano preciso ser&iacute;a bastante dif&iacute;cil. Con MATLAB, el trabajo es mucho menos engorroso.</p>
<pre class="codeinput">plot(t,g(2*t+1)+g(-t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'h(t)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="untitled2_08.png" alt=""> <h2 id="43">1.11-4 Numerical Integration and Estimating Signal Energy</h2>
<p>Las se&ntilde;ales interesantes suelen tener representaciones matem&aacute;ticas no triviales. Computar la energ&iacute;a de la se&ntilde;al, que implica integrar el cuadrado de estas expresiones, puede ser una tarea desalentadora. Afortunadamente, Muchas integrales dif&iacute;ciles se pueden estimar con precisi&oacute;n mediante t&eacute;cnicas de integraci&oacute;n num&eacute;rica. Incluso si la integraci&oacute;n parece simple, la integraci&oacute;n num&eacute;rica proporciona una buena manera de verificar resultados anal&iacute;ticos. Para empezar, considere la se&ntilde;al simple x(t) = e&minus;t (u(t)-u(t-1)). La energ&iacute;a de x(t) se expresa como Ex = integral de &minus;&infin; a &infin; de <tt>x(t)</tt> 2 dt = integrla de 0 a 1 de e^&minus;2t dt. La integraci&oacute;n produce Ex = 0,5(1 &minus; e&minus;2) &asymp; 0,4323. La energ&iacute;a La integral tambi&eacute;n se puede evaluar num&eacute;ricamente. La figura 1.27 ayuda a ilustrar el m&eacute;todo simple de aproximaci&oacute;n rectangular: eval&uacute;e el integrando en puntos separados uniformemente por t, multiplique cada uno por t para calcular las &aacute;reas del rect&aacute;ngulo y luego sumar todos los rect&aacute;ngulos. Primero, creamos la funci&oacute;n. x(t)</p>
<pre class="codeinput"> x = @(t) exp(-t).*((t&gt;=0)&amp;(t&lt;1));
</pre>
<p>Con âˆ†t = 0,01, se crea un vector de tiempo adecuado</p>
<pre class="codeinput"> t = (0:0.01:1);
</pre>
<p>El resultado final se computa usando el comando sum</p>
<pre class="codeinput">  E_x = sum(x(t).*x(t)*0.01);
</pre>
<p>El resultado no es perfecto, pero con un error relativo del 1% est&aacute; cerca. Reduciendo t, la aproximaci&oacute;n es mejorado. Por ejemplo, âˆ†t = 0,001 produce E_x = 0,4328, o un error relativo del 0,1%. Aunque es f&aacute;cil de visualizar, la aproximaci&oacute;n rectangular no es la mejor integraci&oacute;n num&eacute;rica t&eacute;cnica. La funci&oacute;n quad de MATLAB implementa una mejor t&eacute;cnica de integraci&oacute;n num&eacute;rica llamada cuadratura de Simpson adaptativa recursiva.&dagger; Para operar, quad requiere una funci&oacute;n que describa el integrando, el l&iacute;mite inferior de integraci&oacute;n y el l&iacute;mite superior de integraci&oacute;n. Observe que no es necesario especificar. Para utilizar quad para estimar Ex, primero se debe describir el integrando</p>
<pre class="codeinput">x_squared = @(t) x(t).*x(t);
E_x = integral(x_squared,0,1);
</pre>
<p>En este caso, el error relativo es &minus;0,0026%. Se pueden utilizar las mismas t&eacute;cnicas para estimar la energ&iacute;a de se&ntilde;ales m&aacute;s complejas. Considerar g(t), definido anteriormente. La energ&iacute;a se expresa como Eg = $ &infin; 0 e&minus;2t cos2 (2Ï€t)dt. Una soluci&oacute;n de forma cerrada existe, pero requiere algo de esfuerzo. MATLAB proporciona una respuesta m&aacute;s r&aacute;pida</p>
<pre class="codeinput"> g_squared = @(t) g(t).*g(t);
</pre>
<p>Aunque el l&iacute;mite superior de integraci&oacute;n es infinito, la envolvente que decae exponencialmente asegura g(t) es efectivamente cero mucho antes de t = 100. Por lo tanto, se utiliza un l&iacute;mite superior de t = 100 junto con âˆ†t = 0,001.</p>
<pre class="codeinput"> t = (0:0.001:100);
E_g = sum(g_squared(t)*0.001);
</pre>
<p>Un poco mejor obtenida con</p>
<pre class="codeinput">E_g = quad(g_squared,0,100);
</pre>
<h2 id="59">1.12 SUMMARY</h2>
<p>Una se&ntilde;al es un conjunto de datos o informaci&oacute;n. Un sistema procesa se&ntilde;ales de entrada para modificarlas o extraerlas. informaci&oacute;n adicional de ellos para producir se&ntilde;ales de salida (respuesta). Se puede formar un sistema de componentes f&iacute;sicos (realizaci&oacute;n de hardware), o puede ser un algoritmo que calcula una salida se&ntilde;al a partir de una se&ntilde;al de entrada (realizaci&oacute;n de software). Una medida conveniente del tama&ntilde;o de una se&ntilde;al es su energ&iacute;a, si es finita. Si la energ&iacute;a de la se&ntilde;al es infinito, la medida adecuada es su potencia, si existe. La potencia de la se&ntilde;al es el promedio de tiempo de su energ&iacute;a (promediada durante todo el intervalo de tiempo desde &minus;&infin; hasta &infin;). Para se&ntilde;ales peri&oacute;dicas, el tiempo el promedio s&oacute;lo debe realizarse durante un per&iacute;odo en vista de la repetici&oacute;n peri&oacute;dica de la se&ntilde;al. La potencia de la se&ntilde;al tambi&eacute;n es igual al valor medio cuadr&aacute;tico de la se&ntilde;al (promediado durante todo el tiempo). intervalo de t = &minus;&infin; a &infin;). Las se&ntilde;ales se pueden clasificar de varias formas.</p>
<div>
<ul>
<li>1. Se especifica una se&ntilde;al de tiempo continuo para un continuo de valores de la variable independiente. (como el tiempo t). Una se&ntilde;al de tiempo discreto se especifica s&oacute;lo en un conjunto finito o contable de instantes de tiempo.</li>
<li>2. Una se&ntilde;al anal&oacute;gica es una se&ntilde;al cuya amplitud puede tomar cualquier valor en un continuo. En Por otro lado, una se&ntilde;al cuyas amplitudes s&oacute;lo pueden tomar un n&uacute;mero finito de valores es una se&ntilde;al digital. Los t&eacute;rminos tiempo discreto y tiempo continuo califican la naturaleza de una se&ntilde;al. a lo largo del eje del tiempo (eje horizontal). Los t&eacute;rminos anal&oacute;gico y digital, por otro lado, calificar la naturaleza de la amplitud de la se&ntilde;al (eje vertical).</li>
<li>3. Una se&ntilde;al peri&oacute;dica x(t) se define por el hecho de que x(t) = x(t +T0) para alg&uacute;n T0. El mas peque&ntilde;o El valor positivo de T0 para el cual se satisface esta relaci&oacute;n se denomina per&iacute;odo fundamental. Una se&ntilde;al peri&oacute;dica permanece sin cambios cuando se desplaza un m&uacute;ltiplo entero de su per&iacute;odo. Una se&ntilde;al peri&oacute;dica x(t) puede generarse mediante una extensi&oacute;n peri&oacute;dica de cualquier segmento contiguo de x(t) de duraci&oacute;n T0. Finalmente, una se&ntilde;al peri&oacute;dica, por definici&oacute;n, debe existir en todo el intervalo de tiempo &minus;&infin; &lt; t &lt; &infin;. Una se&ntilde;al es aperi&oacute;dica si no es peri&oacute;dica.</li>
<li>4. Una se&ntilde;al eterna comienza en t = &minus;&infin; y contin&uacute;a para siempre hasta t = &infin;. Por lo tanto, peri&oacute;dico Las se&ntilde;ales son se&ntilde;ales eternas. Una se&ntilde;al causal es una se&ntilde;al que es cero para t &lt; 0.</li>
<li>5. Una se&ntilde;al con energ&iacute;a finita es una se&ntilde;al de energ&iacute;a. De manera similar, una se&ntilde;al con finito y distinto de cero La potencia (valor cuadr&aacute;tico medio) es una se&ntilde;al de potencia. Una se&ntilde;al puede ser una se&ntilde;al de energ&iacute;a o una se&ntilde;al de potencia, pero no ambas. Sin embargo, hay se&ntilde;ales que no son ni energ&iacute;a ni potencia. se&ntilde;ales.</li>
<li>6. Una se&ntilde;al cuya descripci&oacute;n f&iacute;sica se conoce completamente en forma matem&aacute;tica o gr&aacute;fica. La forma es una se&ntilde;al determinista. Una se&ntilde;al aleatoria se conoce s&oacute;lo en t&eacute;rminos de su probabilidad. descripci&oacute;n como valor medio o valor cuadr&aacute;tico medio, en lugar de por su valor matem&aacute;tico o forma gr&aacute;fica.</li>
</ul>
</div>
<p>Una se&ntilde;al x(t) retrasada T segundos (desplazada a la derecha) se puede expresar como x(t &minus; T); en el otro Por otro lado, x(t) avanzado por T (desplazado a la izquierda) es x(t + T). Una se&ntilde;al x(t) comprimida en el tiempo por un factor a(a &gt; 1) se expresa como x(at); por otro lado, la misma se&ntilde;al ampliada en el tiempo por el factor a(a &gt; 1) es x(t/a). La se&ntilde;al x(t) cuando se invierte el tiempo se puede expresar como x(&minus;t). La funci&oacute;n de paso unitario u(t) es muy &uacute;til para representar se&ntilde;ales causales y se&ntilde;ales con diferentes descripciones matem&aacute;ticas en diferentes intervalos. En la definici&oacute;n cl&aacute;sica (Dirac), la funci&oacute;n de impulso unitario Î´(t) se caracteriza por un &aacute;rea unitaria y se concentra en un solo instante t = 0. La funci&oacute;n de impulso tiene un muestreo (o tamizado) propiedad, que establece que el &aacute;rea bajo el producto de una funci&oacute;n con un impulso unitario es igual a el valor de esa funci&oacute;n en el instante en que se localiza el impulso (suponiendo que la funci&oacute;n ser continuo en el lugar del impulso). En el enfoque moderno, la funci&oacute;n de impulso se considera como una funci&oacute;n generalizada y est&aacute; definida por la propiedad de muestreo. La funci&oacute;n exponencial est, donde s es compleja, abarca una gran clase de se&ntilde;ales que incluye una constante, una exponencial mon&oacute;tona, una sinusoide y una sinusoide que var&iacute;a exponencialmente. Una se&ntilde;al real que es sim&eacute;trica con respecto al eje vertical (t = 0) es una funci&oacute;n par del tiempo, y una se&ntilde;al real que es antisim&eacute;trica con respecto al eje vertical es una funci&oacute;n impar del tiempo. El El producto de una funci&oacute;n par y una funci&oacute;n impar es una funci&oacute;n impar. Sin embargo, el producto de una funci&oacute;n par y una funci&oacute;n par o una funci&oacute;n impar y una funci&oacute;n impar es una funci&oacute;n par. El &aacute;rea bajo una funci&oacute;n impar desde t = &minus;a hasta a es siempre cero independientemente del valor de a. En por otro lado, el &aacute;rea bajo una funci&oacute;n par desde t = &minus;a hasta a es dos veces el &aacute;rea bajo la misma funci&oacute;n desde t = 0 hasta a (o desde t = &minus;a hasta 0). Cada se&ntilde;al se puede expresar como una suma de funciones pares e impares del tiempo. Un sistema procesa se&ntilde;ales de entrada para producir se&ntilde;ales de salida (respuesta). La entrada es la causa, y el resultado es su efecto. En general, la producci&oacute;n se ve afectada por dos causas: las condiciones internas del sistema (como las condiciones iniciales) y la entrada externa. Los sistemas se pueden clasificar de varias maneras.</p>
<div>
<ul>
<li>1. Los sistemas lineales se caracterizan por la propiedad de linealidad, que implica superposici&oacute;n; si varias causas (como diversas entradas y condiciones iniciales) act&uacute;an sobre un sistema lineal, El resultado total (respuesta) es la suma de las respuestas de cada causa, suponiendo que todas las causas restantes est&aacute;n ausentes. Un sistema es no lineal si no se cumple la superposici&oacute;n.</li>
<li>2. En sistemas invariantes en el tiempo, los par&aacute;metros del sistema no cambian con el tiempo. Los par&aacute;metros de Los sistemas de par&aacute;metros variables en el tiempo cambian con el tiempo.</li>
<li>3. Para sistemas sin memoria (o instant&aacute;neos), la respuesta del sistema en cualquier instante t depende s&oacute;lo en el valor de la entrada en t. Para sistemas con memoria (tambi&eacute;n conocidos como sistemas di&aacute;micos), la respuesta del sistema en cualquier instante t depende no s&oacute;lo del valor presente de la entrada, sino tambi&eacute;n en los valores pasados de la entrada (valores antes de t).</li>
<li>4. Por el contrario, si la respuesta del sistema en t tambi&eacute;n depende de los valores futuros de la entrada (valores de entrada m&aacute;s all&aacute; de t), el sistema es no causal. En los sistemas causales, la respuesta no depende sobre los valores futuros de la entrada. Debido a la dependencia de la respuesta del futuro. valores de entrada, el efecto (respuesta) de los sistemas no causales ocurre antes que la causa. Cuando la variable independiente es el tiempo (sistemas temporales), los sistemas no causales son prof&eacute;ticos sistemas y, por lo tanto, irrealizables, aunque una aproximaci&oacute;n cercana es posible con algunos retraso en la respuesta. Sistemas no causales con variables independientes distintas del tiempo. (por ejemplo, el espacio) son realizables.</li>
<li>5. Los sistemas cuyas entradas y salidas son se&ntilde;ales de tiempo continuo son se&ntilde;ales de tiempo continuo. sistemas; Los sistemas cuyas entradas y salidas son se&ntilde;ales de tiempo discreto son se&ntilde;ales de tiempo discreto. sistemas. Si se muestrea una se&ntilde;al de tiempo continuo, la se&ntilde;al resultante es una se&ntilde;al de tiempo discreto. se&ntilde;al. Podemos procesar una se&ntilde;al de tiempo continuo procesando las muestras de la se&ntilde;al. con un sistema de tiempo discreto.</li>
<li>6. Son sistemas anal&oacute;gicos los sistemas cuyas entradas y salidas sean se&ntilde;ales anal&oacute;gicas; Esos que Las entradas y salidas son se&ntilde;ales digitales, son sistemas digitales.</li>
<li>7. Si podemos obtener la entrada x(t) a partir de la salida y(t) de un sistema S mediante alguna operaci&oacute;n, Se dice que el sistema S es invertible. De lo contrario, el sistema no es invertible.</li>
<li>8. Un sistema es estable si una entrada limitada produce una salida limitada. Esto define lo externo. Estabilidad porque se puede determinar a partir de mediciones en los terminales externos. del sistema. La estabilidad externa tambi&eacute;n se conoce como estabilidad en el BIBO. (entrada limitada/salida limitada). La estabilidad interna, que se analiza m&aacute;s adelante en el cap. 2, es medido en t&eacute;rminos del comportamiento interno del sistema. El modelo del sistema derivado del conocimiento de la estructura interna del sistema es su descripci&oacute;n interna. Por el contrario, una descripci&oacute;n externa es una representaci&oacute;n de un sistema tal como se ve. desde sus terminales de entrada y salida; se puede obtener aplicando una entrada conocida y midiendo la salida resultante. En la mayor&iacute;a de los sistemas pr&aacute;cticos, una descripci&oacute;n externa de un sistema es tan obtenido es equivalente a su descripci&oacute;n interna. A veces, sin embargo, la descripci&oacute;n externa no logra describir adecuadamente el sistema. Tal es el caso de los llamados incontrolables o inobservables. sistemas. Un sistema tambi&eacute;n puede describirse en t&eacute;rminos de cierto conjunto de variables clave llamadas variables de estado. En esta descripci&oacute;n, un sistema de en&eacute;simo orden se puede caracterizar por un conjunto de N sistemas simult&aacute;neos de primer orden. ecuaciones diferenciales en N variables de estado. Las ecuaciones de estado de un sistema representan una ecuaci&oacute;n interna que describe ese sistema.</li>
</ul>
</div>
<h2 id="60">Problema 2</h2>
<p>1.2-2 For the signal x(t) illustrated in Fig. P1.2-2,sketch</p>
<div>
<ul>
<li>(a) x(t &minus;4)</li>
<li>(b) x(t/1.5)</li>
<li>(c) x(&minus;t)</li>
<li>(d) x(2t &minus;4)</li>
<li>(e) x(2&minus;t)</li>
</ul>
</div>
<p>Generando la funci&oacute;n original Iniciamos recreando la se&ntilde;al, mostrada en la grafica que muestra "Lathi" Hacemos anonima la funcion y la guardamos en la varibale "y". Continuamente proponemos un intervalo adecuado y se pueda representar en la grafica correctamente.</p>
<pre class="codeinput">sympref(<span class="string">'HeavisideAtOrigin'</span>,0);
y = @(t) (-t.*(heaviside(t+4)) + 2*t.*(heaviside(t))).*heaviside(-t+2);
t= -7:0.01:7;
plot(t,y(t)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'y(t)'</span>);
title(<span class="string">'Fig. P1.2-2'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_09.png" alt=""> <h2 id="62">a) x(t-4)</h2>
<p>Como se observa en el inciso "A", podemos ver que se trata de una traslacion horizontal en 4 unidades. Por lo que simplemente realizamos la traslacion y la graficamos.</p>
<pre class="codeinput">A=y(t-4);
plot(t,A); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'y(t-4)'</span>);
title(<span class="string">'Figura A'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_10.png" alt=""> <h2 id="64">b) x(t/1.5)</h2>
<p>En el inciso "B" podemos percatarnos que ahora se trata de una division entre la variable "t", pero recordando un poco sobre el comportamiento de las funciones, tenemos que al dividir la variable de la funcion, se ancha la amplitud de manera horizontal sin modificar la altura de la se&ntilde;al original. Por lo que:</p>
<pre class="codeinput">B=y(t./1.5);
plot(t,B); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'y(t/1.5'</span>);
title(<span class="string">'Figura B'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_11.png" alt=""> <p>Como se determino inicialmente, la funcion se ampli de manera horizontal en un valor de 1.5</p>
<h2 id="67">c)x(&minus;t)</h2>
<p>En el inciso "C" se muestra la funcion original, con la unica diferencia que tiene un signo negativo en la "x", esto nos representa una inversion horizontal de la funcion original, es decir, realiza un efecto espejo.</p>
<pre class="codeinput">C=y(-t);
plot(t,C); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'y(-t)'</span>);
title(<span class="string">'Figura C'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_12.png" alt=""> <p>Tal y como se argumento es una inversion horizontal de la funcion original.</p>
<h2 id="70">d) x(2t &minus;4)</h2>
<p>Podemos ver que ahora se presentan dos cambios, una compresion y una traslacion, ambas de manera horizontal, obsevando se deduce que se comprime entre dos, respecto a la funcion original y ademas se traslada 4 unidades.</p>
<pre class="codeinput">D= y(2.*t-4);
plot(t,D); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'y(2t-4)'</span>);
title(<span class="string">'Figura D'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_13.png" alt=""> <h2 id="72">e) x(2&minus;t)</h2>
<p>En el inciso "E" se muestra una "t" negativa y un 2 positivo, reordenando vemos x(-t+2), por lo cual se trata de una inversion y una traslacion, ambas horizontales, la traslacion es de dos unidades.</p>
<pre class="codeinput">E=y(2-t);
plot(t,E); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'y(2-t)'</span>);
title(<span class="string">'Figura E'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_14.png" alt=""> <h2 id="73">Problema 3</h2>
<p>Proporcionar c&oacute;digo MATLAB y resultados que tracen la porci&oacute;n impar xo(t) de la funci&oacute;n x(t) = 2&minus;t cos(2Ï€t)u(t&minus;Ï€) en un intervalo de longitud adecuada utilizando un n&uacute;mero adecuado de puntos.</p>
<p>Para empezar, observamos que x(t) comienza en t = Ï€. Dado que 2&minus;t decae a menos de 1/100 de su resistencia original en 7 segundos, es suficiente representar x(t) en t = 10.</p>
<p>Dado que xo(t) incluye x(t) y su reflexi&oacute;n, a el rango de tiempo adecuado para nuestra gr&aacute;fica es &minus;10 &le; t &le; 10.</p>
<pre class="codeinput"> u = @(t) 1.0*(t&gt;=0); t = -10:1/20:10;
</pre>
<p>Dado que cos(2Ï€t) oscila un ciclo por segundo, a una densidad de trama de 20 puntos por segundo es suficiente para una trama de calidad razonable.</p>
<pre class="codeinput">x = @(t) 2.^(-t).*cos(2*pi*t).*u(t-pi); xo = @(t) (x(t)-x(-t))/2;
</pre>
<p>Usamos la funcion plot con las variables previamente designadas y graficamos:</p>
<pre class="codeinput"> plot(t,xo(t),<span class="string">'k-'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x_o(t)'</span>); grid <span class="string">on</span>;
 axis([-10 10 -1/20 1/20]); set(gca,<span class="string">'xtick'</span>,[-10 -pi 0 pi 10]);
</pre>
<img vspace="5" hspace="5" src="untitled2_15.png" alt=""> <h2 id="81">Problema 4</h2>
<pre>Construye la grafica de</pre>
<p>
<img src="untitled2_eq18343799352459205464.png" alt="$$x(t) = \sum_{k=1}^{10} cos(2\pi k t)$$"></p>
<p>para cuatro rangos (figura 2x2). Los ejes deben mostrarse en el origen adem&aacute;s de la edici&oacute;n de su preferencia.</p>
<p>A continuaci&oacute;n se muestra la grafica:</p>
<p>
<img vspace="5" hspace="5" src="grafica.PNG" alt=""> </p>
<h2 id="83">Problema 5</h2>
<p>Resuelve el problema 1.11-3, agrega como inciso (e) la gr&aacute;fica de <img src="untitled2_eq12659395712222829305.png" alt="$x(t)$"> para <img src="untitled2_eq16434444273656135249.png" alt="$t\in[-10,10]$"></p>
<h2 id="84">Problema 6</h2>
<p>El resultado de esta aplicacion se puede observar en la siguiente imagen, en la cual se ense&ntilde;a como al darle una funcion "t", la grafica y selecciona los intervalos dados, en este caso entre -5 y 2. Donde se puede mostrar que corta a la funcion justo en esos valores de t</p>
<p>
<img vspace="5" hspace="5" src="Problema_6.PNG" alt=""> </p>
<p>Primeramente para explicar, las lineas de codigo tenemos que mostrar los componentes que utilizamos, en primer lugar usamos Axes (Para graficar), Edit Field text(Para ingresar las funciones), Edit Field Numerico (Para ingresar los limites de la funcion y variaciones max y min), Push Button (Para que inicie el proceso de graficacion), Area Text (mostrar raices).</p>
<p>
<img vspace="5" hspace="5" src="Problema_6_b.PNG" alt=""> </p>
<p>Desenglozando el codigo vamos al apartado de callbacks del push button para que todo gire en torno al presionarlo. Primero vamos a leer los caracteres que tiene la funcion que ingresa el usuario, especificamente los valores de cada uno. Despues tenemos que convertir esa funcion en una variable simbolica, llamando a las funciones que nos proporciona MATLAB. Al final describimos la variable simbolica en un vector, despues calulamos las raices del polinomio Y ese valor de las raices las enviamos al area de texto (esto sirve para identificar partes reales de imaginarias). Siguiendo tenemos que programar la seccion para establecer limites de maximos y minimos en valores de x &amp; y para poder tener un campo especifico de la funcion, tomados en intervalos. Asi mismo, damos en el intervalo de integracion de 100 puntos, para que en la grafica se vea fluida la funcion ya graficada. Para graficar haremos uso de la funcion plot, donde se debe especificar que se dibuja en el panel de la grafica. Despues colocamos dos if's en el cual se define los valores de los ejes en x&amp;y, recordando que se reciben valores infinitos, y con ayuda del if, se calcularan automaticamente, con ayuda de los valores maximos de t y l.</p>
<p>
<img vspace="5" hspace="5" src="Problema_6_a.PNG" alt=""> </p>
<h2 id="91">REFERENCIAS</h2>
<div>
<ul>
<li>1. Papoulis, A., La integral de Fourier y sus aplicaciones. McGraw-Hill, Nueva York, 1962.</li>
<li>2. Mason, S. J., Circuitos, se&ntilde;ales y sistemas electr&oacute;nicos. Wiley, Nueva York, 1960.</li>
<li>3. Kailath, T., Sistemas lineales. Prentice-Hall, Englewood Cliffs, Nueva Jersey, 1980.</li>
<li>4. Lathi, B. P., Se&ntilde;ales y sistemas. Prensa de Berkeley-Cambridge, Carmichael, CA, 1987</li>
</ul>
</div>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% PrÃ¡ctica 3: SeÃ±ales en tiempo continuo
%
%
%% Integrantes
%
% * Hernandez LÃ³pez Daniel
% * Jaime HernÃ¡ndez Jaime
% * Ojeda Salgado Rodrigo
% * Reyes Guevara Nathalia
% * Riveros Valencia Javier Alejandro

%% Objetivos de la PrÃ¡ctica
%
% * ManipulaciÃ³n bÃ¡sica de MATLAB
% * GrÃ¡ficas de seÃ±ales reales y complejas continuas
% * TransformaciÃ³n de seÃ±ales continuas (escalamientos y traslaciones)
% * Calculo de energÃ­a y potencia de seÃ±ales continuas
%% IntroducciÃ³n
% Como evidencia de la investigaciÃ²n en Python se grafica lo siguiente:
%%
% 
% <<descarga.PNG>>
% 
% El codigo con el que se genero la grafica pues consultarse en este enlace <https://colab.research.google.com/drive/12C3_0FH1c_eUslcJhYHQlChPufOYX8Cj?usp=sharing> 
%% Desarrollo
% 
%

%% Problema 1
%% 1.11 MATLAB: WORKING WITH FUNCTIONS
%  El trabajo con funciones es fundamental para las aplicaciones de seÃ±ales y sistemas. MATLAB proporciona varios mÃ©todos para definir y evaluar funciones. Por lo tanto, la comprensiÃ³n y el uso competente de estos mÃ©todos son necesarios y beneficiosos.
%% 1.11-1 Anonymous Functions
% Muchas funciones sencillas se representan de forma mÃ¡s cÃ³moda mediante el uso de MATLAB anonymous
% Funciones. Una funciÃ³n anÃ³nima proporciona una representaciÃ³n simbÃ³lica de una funciÃ³n definida en
% tÃ©rminos de operadores, funciones u otras funciones anÃ³nimas de MATLAB. Por ejemplo, considere
% DefiniciÃ³n de la sinusoide exponencialmente amortiguada f(t) = eâˆ’t cos(2Ï€t)
%%
 f = @(t) exp(-t).*cos(2*pi*t) ;
%%
% En este contexto, el sÃ­mbolo @ identifica la expresiÃ³n como una funciÃ³n anÃ³nima, que se asigna  un nombre de f. Los parÃ©ntesis que siguen al sÃ­mbolo @ se utilizan para identificar la funciÃ³n independiente. variables (argumentos de entrada), que en este caso es la Ãºnica variable de tiempo t. Argumentos de entrada, como
% como t, son locales de la funciÃ³n anÃ³nima y no estÃ¡n relacionados con ninguna variable del espacio de trabajo con la
% mismos nombres.
%
% Una vez definida, f(t) se puede evaluar simplemente pasando los valores de entrada de interÃ©s. Para
% ejemplo,
%%
 t = 0; f(t)
 %%
% ans = 1
% evalÃºa f(t) en t = 0, confirmando el resultado esperado de la unidad. El mismo resultado se obtiene mediante
% pasando t = 0 directamente.
%%
f(0)
%%
% respuesta = 1
% Las entradas vectoriales permiten la evaluaciÃ³n de mÃºltiples valores simultÃ¡neamente. Considere la tarea
% de trazar f(t) en el intervalo (âˆ’2 â‰¤ t â‰¤ 2). El comportamiento de la funciÃ³n bruta es claro: f(t) deberÃ­a
% oscilar cuatro veces con una envolvente en decadencia. Dado que los bocetos precisos a mano son engorrosos,
% Los grÃ¡ficos generados por MATLAB son una alternativa atractiva. Como ilustra el siguiente ejemplo, el cuidado
% Se deben tomar medidas para garantizar resultados confiables.
%
% Supongamos que se elige el vector t para incluir solo los nÃºmeros enteros contenidos en (âˆ’2 â‰¤ t â‰¤ 2), es decir,
% [-2,-1, 0, 1, 2].
%%
 t = (-2:2);
%%
% Esta entrada vectorial se evalÃºa para formar una salida vectorial.
%%
 f(t)
 %%
% respuesta = 7,3891 2,7183 1,0000 0,3679 0,135
%
% El comando plot grafica el resultado, que se muestra en la figura 1.46.
%%
plot(t,f(t));
xlabel('t'); ylabel('f(t)'); grid;
%%
% Las lÃ­neas de cuadrÃ­cula, agregadas mediante el comando de cuadrÃ­cula, ayudan a identificar las caracterÃ­sticas. Desafortunadamente, el
% El grÃ¡fico no ilustra el comportamiento oscilatorio esperado. Se requieren mÃ¡s puntos para adecuadamente
% representar f(t).
%
% La pregunta entonces es Â¿cuÃ¡ntos puntos son suficientes?â€  Si se eligen muy pocos puntos, la informaciÃ³n
% estÃ¡ perdido. Si se eligen demasiados puntos, se desperdicia memoria y tiempo. Se necesita un equilibrio.
% Para funciones oscilatorias, normalmente es adecuado trazar de 20 a 200 puntos por oscilaciÃ³n. Para el presente
% En este caso, se elige t para dar 100 puntos por oscilaciÃ³n.
%
%%
t = (-2:0.01:2);
%%
% Nuevamente, la funciÃ³n se evalÃºa y traza:
%% 
plot(t,f(t));
xlabel('tâ€™); ylabel(â€™f(t)'); grid
%%
%% 1.11-2 Relational Operators and the Unit Step Function
% La funciÃ³n escalÃ³n unitario u(t) surge naturalmente en muchas situaciones prÃ¡cticas. Por ejemplo, un paso unitario puede
% Modelar el acto de encender un sistema. Con la ayuda de operadores relacionales, funciones anÃ³nimas.
% puede representar la funciÃ³n de paso unitario.
% En MATLAB, un operador relacional compara dos elementos. Si la comparaciÃ³n es cierta, una verdad lÃ³gica.
% (1) se devuelve. Si la comparaciÃ³n es falsa, se devuelve un falso lÃ³gico (0). A veces llamado indicador
% funciones, los operadores relacionales indican si una condiciÃ³n es verdadera. Seis operadores relacionales son
% disponibles: <, >, <=, >=, == y ~=.
% La funciÃ³n de escalÃ³n unitario se define fÃ¡cilmente usando el operador relacional >=
%%
u = @(t) 1.0.*(t>=0);
%%
% Cualquier funciÃ³n con una discontinuidad de salto, como el escalÃ³n unitario, es difÃ­cil de trazar. Considere la posibilidad de trazar
% u(t) usando t = (-2:2).
%%
t = (-2:2); plot(t,u(t)); 
xlabel('tâ€™); ylabel(â€™u(t)');
%%
% Dos problemas importantes son evidentes en el grÃ¡fico resultante, que se muestra en la figura 1.48. Primero,
% MATLAB escala automÃ¡ticamente los ejes del grÃ¡fico para vincular estrechamente los datos. En este caso, esto normalmente
% La caracterÃ­stica deseable oscurece la mayor parte de la trama. En segundo lugar, MATLAB conecta los datos del trazado con lÃ­neas,
% haciendo que una verdadera discontinuidad de salto sea difÃ­cil de lograr. La resoluciÃ³n gruesa del vector t enfatiza
% el efecto al mostrar una lÃ­nea inclinada errÃ³nea entre t = âˆ’1 y t = 0.
% El primer problema se corrige ampliando verticalmente el cuadro delimitador con el eje
% dominio. El segundo problema se reduce, pero no se elimina, sumando puntos al vector t.
%%
t = (-2:0.01:2); plot(t,u(t));
 xlabel('t'); ylabel('u(t)');
 axis([-2 2 -0.1 1.1]);
 %%
% El argumento vectorial de cuatro elementos del eje especifica el eje x mÃ­nimo, el eje x mÃ¡ximo y el eje y.
% mÃ­nimo y mÃ¡ximo del eje y, respectivamente. Los resultados mejorados se muestran en la figura 1.49.
% Los operadores relacionales se pueden combinar usando AND lÃ³gico, O lÃ³gico y negaciÃ³n lÃ³gica: &,
% | y ~, respectivamente. Por ejemplo, (t>0)&(t<1) y ~((t<=0)|(t>=1)) prueban si 0 < t < 1.
% Para demostrarlo, considere definir y trazar el pulso unitario p(t) = u(t) âˆ’ u(t âˆ’ 1), como se muestra en
% Figura 1.50
%%
 p = @(t) 1.0.*((t>=0)&(t<1));
t = (-1:0.01:2); plot(t,p(t));
xlabel('t'); ylabel('p(t) = u(t)-u(t-1)');
axis([-1 2 -.1 1.1]);
%%
% Dado que las funciones anÃ³nimas se pueden construir utilizando otras funciones anÃ³nimas, podrÃ­amos
% Hemos utilizado nuestra funciÃ³n anÃ³nima de paso unitario previamente definida para definir p(t) como p = @(t)
% u(t)-u(t-1);
% Para operandos escalares, MATLAB tambiÃ©n admite dos construcciones lÃ³gicas de cortocircuito. A
% El AND lÃ³gico de cortocircuito se realiza mediante &&, y el OR lÃ³gico de cortocircuito se realiza mediante
% usando ||. Los operadores lÃ³gicos de cortocircuito suelen ser mÃ¡s eficientes que los operadores lÃ³gicos tradicionales.
% porque prueban la segunda parte de la expresiÃ³n sÃ³lo cuando es necesario. Es decir, cuando escalar
% la expresiÃ³n A se encuentra falsa en (A&&B), la expresiÃ³n escalar B no se evalÃºa, ya que un resultado falso
% ya estÃ¡ garantizado. De manera similar, la expresiÃ³n escalar B no se evalÃºa cuando la expresiÃ³n escalar A es
% encontrado verdadero en (A||B), ya que ya se garantiza un resultado verdadero.
%% 1.11-3 VisualizaciÃ³n de operaciones en la variable independiente
% ComÃºnmente se encuentran dos operaciones sobre la variable independiente de una funciÃ³n: desplazamiento y
% escalada. Las funciones anÃ³nimas son muy adecuadas para investigar ambas operaciones.
% Considere g(t) = f(t)u(t) = eâˆ’t cos(2Ï€t)u(t), una versiÃ³n causal de f(t). MATLAB fÃ¡cilmente
% multiplica funciones anÃ³nimas. Por lo tanto, creamos g(t) multiplicando nuestras funciones anÃ³nimas.
% para f(t) y u(t).
%%
 g = @(t) f(t).*u(t);
 %%
% Una operaciÃ³n combinada de cambio y escala estÃ¡ representada por g(at + b), donde a y b son
% constantes reales arbitrarias. Como ejemplo, considere graficar g(2t +1) sobre (âˆ’2 â‰¤ t â‰¤ 2). Con a = 2,
% la funciÃ³n se comprime por un factor de 2, lo que da como resultado el doble de oscilaciones por unidad t. AÃ±adiendo
% la condiciÃ³n b > 0 desplaza la forma de onda hacia la izquierda. Dada la funciÃ³n anÃ³nima g, una grÃ¡fica precisa
% es casi trivial de obtener
%%
 t = (-2:0.01:2);
plot(t,g(2*t+1)); xlabel('t'); ylabel('g(2t+1)'); grid;
%%
% La Figura 1.51 confirma la compresiÃ³n esperada de la forma de onda y el desplazamiento hacia la izquierda. Como comprobaciÃ³n final, tenga en cuenta
% esa funciÃ³n g(Â·) se activa cuando el argumento de entrada es cero. Por lo tanto, g(2t + 1) deberÃ­a activarse
% cuando 2t +1 = 0 o en t = âˆ’0.5, hecho confirmado nuevamente por la figura 1.51.
% A continuaciÃ³n, considere graficar g(âˆ’t + 1) sobre (âˆ’2 â‰¤ t â‰¤ 2). Como a < 0, la forma de onda serÃ¡
% reflejado. Agregar la condiciÃ³n b > 0 desplaza la forma de onda final hacia la derecha.
%%
plot(t,g(-t+1)); xlabel('t'); ylabel('g(-t+1)'); grid;
%%
% La figura 1.52 confirma tanto la reflexiÃ³n como el desplazamiento a la derecha.
% Hasta este punto, las Figs. 1,51 y 1,52 podrÃ­an esbozarse razonablemente a mano. Considere la posibilidad de trazar
% la funciÃ³n mÃ¡s complicada h(t) = g(2t + 1) + g(âˆ’t + 1) sobre (âˆ’2 â‰¤ t â‰¤ 2) (figura 1.53); un
% Un boceto a mano preciso serÃ­a bastante difÃ­cil. Con MATLAB, el trabajo es mucho menos engorroso.
%%
plot(t,g(2*t+1)+g(-t+1)); xlabel('t'); ylabel('h(t)'); grid;
%%

%% 1.11-4 Numerical Integration and Estimating Signal Energy
% Las seÃ±ales interesantes suelen tener representaciones matemÃ¡ticas no triviales. Computar la energÃ­a de la seÃ±al,
% que implica integrar el cuadrado de estas expresiones, puede ser una tarea desalentadora. Afortunadamente,
% Muchas integrales difÃ­ciles se pueden estimar con precisiÃ³n mediante tÃ©cnicas de integraciÃ³n numÃ©rica.
% Incluso si la integraciÃ³n parece simple, la integraciÃ³n numÃ©rica proporciona una buena manera de verificar
% resultados analÃ­ticos.
% Para empezar, considere la seÃ±al simple x(t) = eâˆ’t
% (u(t)-u(t-1)). La energÃ­a de x(t) se expresa
% como Ex = integral de âˆ’âˆž a âˆž de |x(t)|
% 2 dt = integrla de 0 a 1 de e^âˆ’2t dt. La integraciÃ³n produce Ex = 0,5(1 âˆ’ eâˆ’2) â‰ˆ 0,4323. La energÃ­a
% La integral tambiÃ©n se puede evaluar numÃ©ricamente. La figura 1.27 ayuda a ilustrar el mÃ©todo simple de
% aproximaciÃ³n rectangular: evalÃºe el integrando en puntos separados uniformemente por t, multiplique
% cada uno por t para calcular las Ã¡reas del rectÃ¡ngulo y luego sumar todos los rectÃ¡ngulos. Primero, creamos la funciÃ³n.
% x(t)
%%
 x = @(t) exp(-t).*((t>=0)&(t<1));
 %%
% Con âˆ†t = 0,01, se crea un vector de tiempo adecuado
%%
 t = (0:0.01:1);
 %%
 % El resultado final se computa usando el comando sum
 %%
  E_x = sum(x(t).*x(t)*0.01);
 %%
 
%%
% El resultado no es perfecto, pero con un error relativo del 1% estÃ¡ cerca. Reduciendo t, la aproximaciÃ³n es
% mejorado. Por ejemplo, âˆ†t = 0,001 produce E_x = 0,4328, o un error relativo del 0,1%.
% Aunque es fÃ¡cil de visualizar, la aproximaciÃ³n rectangular no es la mejor integraciÃ³n numÃ©rica
% tÃ©cnica. La funciÃ³n quad de MATLAB implementa una mejor tÃ©cnica de integraciÃ³n numÃ©rica
% llamada cuadratura de Simpson adaptativa recursiva.â€  Para operar, quad requiere una funciÃ³n que describa
% el integrando, el lÃ­mite inferior de integraciÃ³n y el lÃ­mite superior de integraciÃ³n. Observe que no
% es necesario especificar.
% Para utilizar quad para estimar Ex, primero se debe describir el integrando
%%
x_squared = @(t) x(t).*x(t);
E_x = integral(x_squared,0,1);
%%
% En este caso, el error relativo es âˆ’0,0026%.
% Se pueden utilizar las mismas tÃ©cnicas para estimar la energÃ­a de seÃ±ales mÃ¡s complejas. Considerar
% g(t), definido anteriormente. La energÃ­a se expresa como Eg = $ âˆž
% 0 eâˆ’2t cos2 (2Ï€t)dt. Una soluciÃ³n de forma cerrada
% existe, pero requiere algo de esfuerzo. MATLAB proporciona una respuesta mÃ¡s rÃ¡pida
%%
 g_squared = @(t) g(t).*g(t);
%%
% Aunque el lÃ­mite superior de integraciÃ³n es infinito, la envolvente que decae exponencialmente asegura
% g(t) es efectivamente cero mucho antes de t = 100. Por lo tanto, se utiliza un lÃ­mite superior de t = 100 junto con
% âˆ†t = 0,001.
%%
 t = (0:0.001:100);
E_g = sum(g_squared(t)*0.001);
%%
% Un poco mejor obtenida con 
%%
E_g = quad(g_squared,0,100);
%%
%% 1.12 SUMMARY
% Una seÃ±al es un conjunto de datos o informaciÃ³n. Un sistema procesa seÃ±ales de entrada para modificarlas o extraerlas.
% informaciÃ³n adicional de ellos para producir seÃ±ales de salida (respuesta). Se puede formar un sistema
% de componentes fÃ­sicos (realizaciÃ³n de hardware), o puede ser un algoritmo que calcula una salida
% seÃ±al a partir de una seÃ±al de entrada (realizaciÃ³n de software).
% Una medida conveniente del tamaÃ±o de una seÃ±al es su energÃ­a, si es finita. Si la energÃ­a de la seÃ±al es
% infinito, la medida adecuada es su potencia, si existe. La potencia de la seÃ±al es el promedio de tiempo de
% su energÃ­a (promediada durante todo el intervalo de tiempo desde âˆ’âˆž hasta âˆž). Para seÃ±ales periÃ³dicas, el tiempo
% el promedio sÃ³lo debe realizarse durante un perÃ­odo en vista de la repeticiÃ³n periÃ³dica de la seÃ±al.
% La potencia de la seÃ±al tambiÃ©n es igual al valor medio cuadrÃ¡tico de la seÃ±al (promediado durante todo el tiempo).
% intervalo de t = âˆ’âˆž a âˆž).
% Las seÃ±ales se pueden clasificar de varias formas.
%
% * 1. Se especifica una seÃ±al de tiempo continuo para un continuo de valores de la variable independiente.
% (como el tiempo t). Una seÃ±al de tiempo discreto se especifica sÃ³lo en un conjunto finito o contable de
% instantes de tiempo.
% * 2. Una seÃ±al analÃ³gica es una seÃ±al cuya amplitud puede tomar cualquier valor en un continuo. En
% Por otro lado, una seÃ±al cuyas amplitudes sÃ³lo pueden tomar un nÃºmero finito de valores es una
% seÃ±al digital. Los tÃ©rminos tiempo discreto y tiempo continuo califican la naturaleza de una seÃ±al.
% a lo largo del eje del tiempo (eje horizontal). Los tÃ©rminos analÃ³gico y digital, por otro lado,
% calificar la naturaleza de la amplitud de la seÃ±al (eje vertical).
% * 3. Una seÃ±al periÃ³dica x(t) se define por el hecho de que x(t) = x(t +T0) para algÃºn T0. El mas pequeÃ±o
% El valor positivo de T0 para el cual se satisface esta relaciÃ³n se denomina perÃ­odo fundamental.
% Una seÃ±al periÃ³dica permanece sin cambios cuando se desplaza un mÃºltiplo entero de su perÃ­odo.
% Una seÃ±al periÃ³dica x(t) puede generarse mediante una extensiÃ³n periÃ³dica de cualquier segmento contiguo
% de x(t) de duraciÃ³n T0. Finalmente, una seÃ±al periÃ³dica, por definiciÃ³n, debe existir en todo el
% intervalo de tiempo âˆ’âˆž < t < âˆž. Una seÃ±al es aperiÃ³dica si no es periÃ³dica.
% * 4. Una seÃ±al eterna comienza en t = âˆ’âˆž y continÃºa para siempre hasta t = âˆž. Por lo tanto, periÃ³dico
% Las seÃ±ales son seÃ±ales eternas. Una seÃ±al causal es una seÃ±al que es cero para t < 0.
% * 5. Una seÃ±al con energÃ­a finita es una seÃ±al de energÃ­a. De manera similar, una seÃ±al con finito y distinto de cero
% La potencia (valor cuadrÃ¡tico medio) es una seÃ±al de potencia. Una seÃ±al puede ser una seÃ±al de energÃ­a o
% una seÃ±al de potencia, pero no ambas. Sin embargo, hay seÃ±ales que no son ni energÃ­a ni potencia.
% seÃ±ales.
% * 6. Una seÃ±al cuya descripciÃ³n fÃ­sica se conoce completamente en forma matemÃ¡tica o grÃ¡fica.
% La forma es una seÃ±al determinista. Una seÃ±al aleatoria se conoce sÃ³lo en tÃ©rminos de su probabilidad.
% descripciÃ³n como valor medio o valor cuadrÃ¡tico medio, en lugar de por su valor matemÃ¡tico o
% forma grÃ¡fica.
%
% Una seÃ±al x(t) retrasada T segundos (desplazada a la derecha) se puede expresar como x(t âˆ’ T); en el otro
% Por otro lado, x(t) avanzado por T (desplazado a la izquierda) es x(t + T). Una seÃ±al x(t) comprimida en el tiempo por un factor
% a(a > 1) se expresa como x(at); por otro lado, la misma seÃ±al ampliada en el tiempo por el factor a(a > 1)
% es x(t/a). La seÃ±al x(t) cuando se invierte el tiempo se puede expresar como x(âˆ’t).
% La funciÃ³n de paso unitario u(t) es muy Ãºtil para representar seÃ±ales causales y seÃ±ales con
% diferentes descripciones matemÃ¡ticas en diferentes intervalos.
% En la definiciÃ³n clÃ¡sica (Dirac), la funciÃ³n de impulso unitario Î´(t) se caracteriza por un Ã¡rea unitaria
% y se concentra en un solo instante t = 0. La funciÃ³n de impulso tiene un muestreo (o tamizado)
% propiedad, que establece que el Ã¡rea bajo el producto de una funciÃ³n con un impulso unitario es igual a
% el valor de esa funciÃ³n en el instante en que se localiza el impulso (suponiendo que la funciÃ³n
% ser continuo en el lugar del impulso). En el enfoque moderno, la funciÃ³n de impulso se considera como
% una funciÃ³n generalizada y estÃ¡ definida por la propiedad de muestreo.
% La funciÃ³n exponencial est, donde s es compleja, abarca una gran clase de seÃ±ales que
% incluye una constante, una exponencial monÃ³tona, una sinusoide y una sinusoide que varÃ­a exponencialmente.
% Una seÃ±al real que es simÃ©trica con respecto al eje vertical (t = 0) es una funciÃ³n par del tiempo,
% y una seÃ±al real que es antisimÃ©trica con respecto al eje vertical es una funciÃ³n impar del tiempo. El
% El producto de una funciÃ³n par y una funciÃ³n impar es una funciÃ³n impar. Sin embargo, el producto de una
% funciÃ³n par y una funciÃ³n par o una funciÃ³n impar y una funciÃ³n impar es una funciÃ³n par.
% El Ã¡rea bajo una funciÃ³n impar desde t = âˆ’a hasta a es siempre cero independientemente del valor de a. En
% por otro lado, el Ã¡rea bajo una funciÃ³n par desde t = âˆ’a hasta a es dos veces el Ã¡rea bajo la
% misma funciÃ³n desde t = 0 hasta a (o desde t = âˆ’a hasta 0). Cada seÃ±al se puede expresar como una suma de
% funciones pares e impares del tiempo.
% Un sistema procesa seÃ±ales de entrada para producir seÃ±ales de salida (respuesta). La entrada es la causa,
% y el resultado es su efecto. En general, la producciÃ³n se ve afectada por dos causas: las condiciones internas
% del sistema (como las condiciones iniciales) y la entrada externa.
% Los sistemas se pueden clasificar de varias maneras.
%
% * 1. Los sistemas lineales se caracterizan por la propiedad de linealidad, que implica superposiciÃ³n; si
% varias causas (como diversas entradas y condiciones iniciales) actÃºan sobre un sistema lineal,
% El resultado total (respuesta) es la suma de las respuestas de cada causa, suponiendo que todas
% las causas restantes estÃ¡n ausentes. Un sistema es no lineal si no se cumple la superposiciÃ³n.
% * 2. En sistemas invariantes en el tiempo, los parÃ¡metros del sistema no cambian con el tiempo. Los parÃ¡metros de
% Los sistemas de parÃ¡metros variables en el tiempo cambian con el tiempo.
% * 3. Para sistemas sin memoria (o instantÃ¡neos), la respuesta del sistema en cualquier instante t depende
% sÃ³lo en el valor de la entrada en t. Para sistemas con memoria (tambiÃ©n conocidos como sistemas diÃ¡micos), la respuesta del sistema en cualquier instante t depende no sÃ³lo del valor presente de la
% entrada, sino tambiÃ©n en los valores pasados de la entrada (valores antes de t).
% * 4. Por el contrario, si la respuesta del sistema en t tambiÃ©n depende de los valores futuros de la entrada (valores de
% entrada mÃ¡s allÃ¡ de t), el sistema es no causal. En los sistemas causales, la respuesta no depende
% sobre los valores futuros de la entrada. Debido a la dependencia de la respuesta del futuro.
% valores de entrada, el efecto (respuesta) de los sistemas no causales ocurre antes que la causa. Cuando
% la variable independiente es el tiempo (sistemas temporales), los sistemas no causales son profÃ©ticos
% sistemas y, por lo tanto, irrealizables, aunque una aproximaciÃ³n cercana es posible con algunos
% retraso en la respuesta. Sistemas no causales con variables independientes distintas del tiempo.
% (por ejemplo, el espacio) son realizables.
% * 5. Los sistemas cuyas entradas y salidas son seÃ±ales de tiempo continuo son seÃ±ales de tiempo continuo.
% sistemas; Los sistemas cuyas entradas y salidas son seÃ±ales de tiempo discreto son seÃ±ales de tiempo discreto.
% sistemas. Si se muestrea una seÃ±al de tiempo continuo, la seÃ±al resultante es una seÃ±al de tiempo discreto.
% seÃ±al. Podemos procesar una seÃ±al de tiempo continuo procesando las muestras de la seÃ±al.
% con un sistema de tiempo discreto.
% * 6. Son sistemas analÃ³gicos los sistemas cuyas entradas y salidas sean seÃ±ales analÃ³gicas; Esos que
% Las entradas y salidas son seÃ±ales digitales, son sistemas digitales.
% * 7. Si podemos obtener la entrada x(t) a partir de la salida y(t) de un sistema S mediante alguna operaciÃ³n,
% Se dice que el sistema S es invertible. De lo contrario, el sistema no es invertible.
% * 8. Un sistema es estable si una entrada limitada produce una salida limitada. Esto define lo externo.
% Estabilidad porque se puede determinar a partir de mediciones en los terminales externos.
% del sistema. La estabilidad externa tambiÃ©n se conoce como estabilidad en el BIBO.
% (entrada limitada/salida limitada). La estabilidad interna, que se analiza mÃ¡s adelante en el cap. 2, es
% medido en tÃ©rminos del comportamiento interno del sistema.
% El modelo del sistema derivado del conocimiento de la estructura interna del sistema es su
% descripciÃ³n interna. Por el contrario, una descripciÃ³n externa es una representaciÃ³n de un sistema tal como se ve.
% desde sus terminales de entrada y salida; se puede obtener aplicando una entrada conocida y midiendo
% la salida resultante. En la mayorÃ­a de los sistemas prÃ¡cticos, una descripciÃ³n externa de un sistema es tan
% obtenido es equivalente a su descripciÃ³n interna. A veces, sin embargo, la descripciÃ³n externa no logra
% describir adecuadamente el sistema. Tal es el caso de los llamados incontrolables o inobservables.
% sistemas.
% Un sistema tambiÃ©n puede describirse en tÃ©rminos de cierto conjunto de variables clave llamadas variables de estado.
% En esta descripciÃ³n, un sistema de enÃ©simo orden se puede caracterizar por un conjunto de N sistemas simultÃ¡neos de primer orden.
% ecuaciones diferenciales en N variables de estado. Las ecuaciones de estado de un sistema representan una ecuaciÃ³n interna que describe ese sistema.
%

%% Problema 2
% 1.2-2 For the signal x(t) illustrated in Fig. P1.2-2,sketch
%
% * (a) x(t âˆ’4)
% * (b) x(t/1.5)
% * (c) x(âˆ’t)
% * (d) x(2t âˆ’4)
% * (e) x(2âˆ’t)
%
% Generando la funciÃ³n original
% Iniciamos recreando la seÃ±al, mostrada en la grafica que muestra "Lathi" Hacemos anonima la funcion y la guardamos en la varibale "y". Continuamente proponemos un intervalo adecuado y se pueda representar en la grafica correctamente.
%%
sympref('HeavisideAtOrigin',0);
y = @(t) (-t.*(heaviside(t+4)) + 2*t.*(heaviside(t))).*heaviside(-t+2);
t= -7:0.01:7;
plot(t,y(t)); xlabel('t'); ylabel('y(t)');
title('Fig. P1.2-2');

%% a) x(t-4)
% Como se observa en el inciso "A", podemos ver que se trata de una traslacion horizontal en 4 unidades. Por lo que simplemente realizamos la traslacion y la graficamos.
%%
A=y(t-4);
plot(t,A); xlabel('t'); ylabel('y(t-4)');
title('Figura A');

%% b) x(t/1.5)
% En el inciso "B" podemos percatarnos que ahora se trata de una division entre la variable "t", pero recordando un poco sobre el comportamiento de las funciones, tenemos que al dividir la variable de la funcion, se ancha la amplitud de manera horizontal sin modificar la altura de la seÃ±al original. Por lo que:
%%
B=y(t./1.5);
plot(t,B); xlabel('t'); ylabel('y(t/1.5');
title('Figura B');
%%
% Como se determino inicialmente, la funcion se ampli de manera horizontal en un valor de 1.5
%% c)x(âˆ’t)
% En el inciso "C" se muestra la funcion original, con la unica diferencia que tiene un signo negativo en la "x", esto nos representa una inversion horizontal de la funcion original, es decir, realiza un efecto espejo.
%%
C=y(-t);
plot(t,C); xlabel('t'); ylabel('y(-t)');
title('Figura C');
%%
% Tal y como se argumento es una inversion horizontal de la funcion original.
%% d) x(2t âˆ’4)
% Podemos ver que ahora se presentan dos cambios, una compresion y una traslacion, ambas de manera horizontal, obsevando se deduce que se comprime entre dos, respecto a la funcion original y ademas se traslada 4 unidades.
%%
D= y(2.*t-4);
plot(t,D); xlabel('t'); ylabel('y(2t-4)');
title('Figura D');
%% e) x(2âˆ’t)
% En el inciso "E" se muestra una "t" negativa y un 2 positivo, reordenando vemos x(-t+2), por lo cual se trata de una inversion y una traslacion, ambas horizontales, la traslacion es de dos unidades.
E=y(2-t);
plot(t,E); xlabel('t'); ylabel('y(2-t)');
title('Figura E');

%% Problema 3
% Proporcionar cÃ³digo MATLAB y resultados que tracen la porciÃ³n impar xo(t) de la funciÃ³n x(t) = 2âˆ’t cos(2Ï€t)u(tâˆ’Ï€) en un intervalo de longitud adecuada utilizando un nÃºmero adecuado de puntos.
%
% Para empezar, observamos que x(t) comienza en t = Ï€. Dado que 2âˆ’t decae a menos de 1/100 de su resistencia original en 7 segundos, es suficiente representar x(t) en t = 10.
%%
% Dado que xo(t) incluye x(t) y su reflexiÃ³n, a el rango de tiempo adecuado para nuestra grÃ¡fica es âˆ’10 â‰¤ t â‰¤ 10. 
%%
 u = @(t) 1.0*(t>=0); t = -10:1/20:10;
%%
% Dado que cos(2Ï€t) oscila un ciclo por segundo, a una densidad de trama de 20 puntos por segundo es suficiente para una trama de calidad razonable.
%%
x = @(t) 2.^(-t).*cos(2*pi*t).*u(t-pi); xo = @(t) (x(t)-x(-t))/2;
%%
% Usamos la funcion plot con las variables previamente designadas y graficamos:
%%
 plot(t,xo(t),'k-'); xlabel('t'); ylabel('x_o(t)'); grid on;
 axis([-10 10 -1/20 1/20]); set(gca,'xtick',[-10 -pi 0 pi 10]);
%%
%% Problema 4 
%  Construye la grafica de
%
% $$x(t) = \sum_{k=1}^{10} cos(2\pi k t)$$
%
% para cuatro rangos (figura 2x2). Los ejes deben mostrarse en el origen ademÃ¡s de la ediciÃ³n de su preferencia.
%
% A continuaciÃ³n se muestra la grafica:

%%
% 
% <<grafica.PNG>>
% 

 


%% Problema 5
% Resuelve el problema 1.11-3, agrega como inciso (e) la grÃ¡fica de 
% $x(t)$ para $t\in[-10,10]$ 

%% Problema 6
%%
% El resultado de esta aplicacion se puede observar en la siguiente imagen, en la cual se enseÃ±a como al darle una funcion "t", la grafica y selecciona los intervalos dados, en este caso entre -5 y 2. Donde se puede mostrar que corta a la funcion justo en esos valores de t
%%
% 
% <<Problema_6.PNG>>
%%
% Primeramente para explicar, las lineas de codigo tenemos que mostrar los componentes que utilizamos, en primer lugar usamos Axes (Para graficar), Edit Field text(Para ingresar las funciones), Edit Field Numerico (Para ingresar los limites de la funcion y variaciones max y min), Push Button (Para que inicie el proceso de graficacion), Area Text (mostrar raices).
%%
% 
% <<Problema_6_b.PNG>>
% 
%%
% Desenglozando el codigo vamos al apartado de callbacks del push button para que todo gire en torno al presionarlo. Primero vamos a leer los caracteres que tiene la funcion que ingresa el usuario, especificamente los valores de cada uno. Despues tenemos que convertir esa funcion en una variable simbolica, llamando a las funciones que nos proporciona MATLAB. Al final describimos la variable simbolica en un vector, despues calulamos las raices del polinomio Y ese valor de las raices las enviamos al area de texto (esto sirve para identificar partes reales de imaginarias). Siguiendo tenemos que programar la seccion para establecer limites de maximos y minimos en valores de x & y para poder tener un campo especifico de la funcion, tomados en intervalos. Asi mismo, damos en el intervalo de integracion de 100 puntos, para que en la grafica se vea fluida la funcion ya graficada. Para graficar haremos uso de la funcion plot, donde se debe especificar que se dibuja en el panel de la grafica. Despues colocamos dos if's en el cual se define los valores de los ejes en x&y, recordando que se reciben valores infinitos, y con ayuda del if, se calcularan automaticamente, con ayuda de los valores maximos de t y l.
%%
% 
% <<Problema_6_a.PNG>>
% 






%% REFERENCIAS
% * 1. Papoulis, A., La integral de Fourier y sus aplicaciones. McGraw-Hill, Nueva York, 1962.
% * 2. Mason, S. J., Circuitos, seÃ±ales y sistemas electrÃ³nicos. Wiley, Nueva York, 1960.
% * 3. Kailath, T., Sistemas lineales. Prentice-Hall, Englewood Cliffs, Nueva Jersey, 1980.
% * 4. Lathi, B. P., SeÃ±ales y sistemas. Prensa de Berkeley-Cambridge, Carmichael, CA, 1987

##### SOURCE END #####
-->
</body>
</html>
