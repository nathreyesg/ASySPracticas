<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>Pr&aacute;ctica 3: Se&ntilde;ales en tiempo continuo</title>
<meta name="generator" content="MATLAB 23.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-03-18">
<meta name="DC.source" content="untitled2.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h1>Pr&aacute;ctica 3: Se&ntilde;ales en tiempo continuo</h1>
<!--introduction-->
<!--/introduction-->
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Integrantes</a>
</li>
<li>
<a href="#2">Objetivos de la Pr&aacute;ctica</a>
</li>
<li>
<a href="#3">Introducci&oacute;n</a>
</li>
<li>
<a href="#5">Desarrollo</a>
</li>
<li>
<a href="#6">Problema 1</a>
</li>
<li>
<a href="#7">1.11 MATLAB: WORKING WITH FUNCTIONS</a>
</li>
<li>
<a href="#8">1.11-1 Anonymous Functions</a>
</li>
<li>
<a href="#25">1.11-2 Relational Operators and the Unit Step Function</a>
</li>
<li>
<a href="#34">1.11-3 Visualizaci&oacute;n de operaciones en la variable independiente</a>
</li>
<li>
<a href="#43">1.11-4 Numerical Integration and Estimating Signal Energy</a>
</li>
<li>
<a href="#59">1.12 SUMMARY</a>
</li>
<li>
<a href="#60">Problema 2</a>
</li>
<li>
<a href="#62">a) x(t-4)</a>
</li>
<li>
<a href="#64">b) x(t/1.5)</a>
</li>
<li>
<a href="#67">c)x(&minus;t)</a>
</li>
<li>
<a href="#70">d) x(2t &minus;4)</a>
</li>
<li>
<a href="#72">e) x(2&minus;t)</a>
</li>
<li>
<a href="#73">Problema 3</a>
</li>
<li>
<a href="#81">Problema 4</a>
</li>
<li>
<a href="#83">Problema 5</a>
</li>
<li>
<a href="#84">Problema 6</a>
</li>
<li>
<a href="#91">REFERENCIAS</a>
</li>
</ul>
</div>
<h2 id="1">Integrantes</h2>
<div>
<ul>
<li>Hernandez L&oacute;pez Daniel</li>
<li>Jaime Hern&aacute;ndez Jaime</li>
<li>Ojeda Salgado Rodrigo</li>
<li>Reyes Guevara Nathalia</li>
<li>Riveros Valencia Javier Alejandro</li>
</ul>
</div>
<h2 id="2">Objetivos de la Pr&aacute;ctica</h2>
<div>
<ul>
<li>Manipulaci&oacute;n b&aacute;sica de MATLAB</li>
<li>Gr&aacute;ficas de se&ntilde;ales reales y complejas continuas</li>
<li>Transformaci&oacute;n de se&ntilde;ales continuas (escalamientos y traslaciones)</li>
<li>Calculo de energ&iacute;a y potencia de se&ntilde;ales continuas</li>
</ul>
</div>
<h2 id="3">Introducci&oacute;n</h2>
<p>Como evidencia de la investigaci&ograve;n en Python se grafica lo siguiente:</p>
<p>
<img vspace="5" hspace="5" src="descarga.PNG" alt=""> </p>
<p>El codigo con el que se genero la grafica pues consultarse en este enlace <a href="https://colab.research.google.com/drive/12C3_0FH1c_eUslcJhYHQlChPufOYX8Cj?usp=sharing">https://colab.research.google.com/drive/12C3_0FH1c_eUslcJhYHQlChPufOYX8Cj?usp=sharing</a>
</p>
<h2 id="5">Desarrollo</h2>
<h2 id="6">Problema 1</h2>
<h2 id="7">1.11 MATLAB: WORKING WITH FUNCTIONS</h2>
<pre>El trabajo con funciones es fundamental para las aplicaciones de se&ntilde;ales y sistemas. MATLAB proporciona varios m&eacute;todos para definir y evaluar funciones. Por lo tanto, la comprensi&oacute;n y el uso competente de estos m&eacute;todos son necesarios y beneficiosos.</pre>
<h2 id="8">1.11-1 Anonymous Functions</h2>
<p>Muchas funciones sencillas se representan de forma m&aacute;s c&oacute;moda mediante el uso de MATLAB anonymous Funciones. Una funci&oacute;n an&oacute;nima proporciona una representaci&oacute;n simb&oacute;lica de una funci&oacute;n definida en t&eacute;rminos de operadores, funciones u otras funciones an&oacute;nimas de MATLAB. Por ejemplo, considere Definici&oacute;n de la sinusoide exponencialmente amortiguada f(t) = e&minus;t cos(2πt)</p>
<pre class="codeinput"> f = @(t) exp(-t).*cos(2*pi*t) ;
</pre>
<p>En este contexto, el s&iacute;mbolo @ identifica la expresi&oacute;n como una funci&oacute;n an&oacute;nima, que se asigna un nombre de f. Los par&eacute;ntesis que siguen al s&iacute;mbolo @ se utilizan para identificar la funci&oacute;n independiente. variables (argumentos de entrada), que en este caso es la &uacute;nica variable de tiempo t. Argumentos de entrada, como como t, son locales de la funci&oacute;n an&oacute;nima y no est&aacute;n relacionados con ninguna variable del espacio de trabajo con la mismos nombres.</p>
<p>Una vez definida, f(t) se puede evaluar simplemente pasando los valores de entrada de inter&eacute;s. Para ejemplo,</p>
<pre class="codeinput"> t = 0; f(t)
</pre>
<pre class="codeoutput">
ans =

     1

</pre>
<p>ans = 1 eval&uacute;a f(t) en t = 0, confirmando el resultado esperado de la unidad. El mismo resultado se obtiene mediante pasando t = 0 directamente.</p>
<pre class="codeinput">f(0)
</pre>
<pre class="codeoutput">
ans =

     1

</pre>
<p>respuesta = 1 Las entradas vectoriales permiten la evaluaci&oacute;n de m&uacute;ltiples valores simult&aacute;neamente. Considere la tarea de trazar f(t) en el intervalo (&minus;2 &le; t &le; 2). El comportamiento de la funci&oacute;n bruta es claro: f(t) deber&iacute;a oscilar cuatro veces con una envolvente en decadencia. Dado que los bocetos precisos a mano son engorrosos, Los gr&aacute;ficos generados por MATLAB son una alternativa atractiva. Como ilustra el siguiente ejemplo, el cuidado Se deben tomar medidas para garantizar resultados confiables.</p>
<p>Supongamos que se elige el vector t para incluir solo los n&uacute;meros enteros contenidos en (&minus;2 &le; t &le; 2), es decir, [-2,-1, 0, 1, 2].</p>
<pre class="codeinput"> t = (-2:2);
</pre>
<p>Esta entrada vectorial se eval&uacute;a para formar una salida vectorial.</p>
<pre class="codeinput"> f(t)
</pre>
<pre class="codeoutput">
ans =

    7.3891    2.7183    1.0000    0.3679    0.1353

</pre>
<p>respuesta = 7,3891 2,7183 1,0000 0,3679 0,135</p>
<p>El comando plot grafica el resultado, que se muestra en la figura 1.46.</p>
<pre class="codeinput">plot(t,f(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'f(t)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="untitled2_01.png" alt=""> <p>Las l&iacute;neas de cuadr&iacute;cula, agregadas mediante el comando de cuadr&iacute;cula, ayudan a identificar las caracter&iacute;sticas. Desafortunadamente, el El gr&aacute;fico no ilustra el comportamiento oscilatorio esperado. Se requieren m&aacute;s puntos para adecuadamente representar f(t).</p>
<p>La pregunta entonces es &iquest;cu&aacute;ntos puntos son suficientes?&dagger; Si se eligen muy pocos puntos, la informaci&oacute;n est&aacute; perdido. Si se eligen demasiados puntos, se desperdicia memoria y tiempo. Se necesita un equilibrio. Para funciones oscilatorias, normalmente es adecuado trazar de 20 a 200 puntos por oscilaci&oacute;n. Para el presente En este caso, se elige t para dar 100 puntos por oscilaci&oacute;n.</p>
<pre class="codeinput">t = (-2:0.01:2);
</pre>
<p>Nuevamente, la funci&oacute;n se eval&uacute;a y traza:</p>
<pre class="codeinput">plot(t,f(t));
xlabel(<span class="string">'t&rsquo;); ylabel(&rsquo;f(t)'</span>); grid
</pre>
<img vspace="5" hspace="5" src="untitled2_02.png" alt=""> <h2 id="25">1.11-2 Relational Operators and the Unit Step Function</h2>
<p>La funci&oacute;n escal&oacute;n unitario u(t) surge naturalmente en muchas situaciones pr&aacute;cticas. Por ejemplo, un paso unitario puede Modelar el acto de encender un sistema. Con la ayuda de operadores relacionales, funciones an&oacute;nimas. puede representar la funci&oacute;n de paso unitario. En MATLAB, un operador relacional compara dos elementos. Si la comparaci&oacute;n es cierta, una verdad l&oacute;gica. (1) se devuelve. Si la comparaci&oacute;n es falsa, se devuelve un falso l&oacute;gico (0). A veces llamado indicador funciones, los operadores relacionales indican si una condici&oacute;n es verdadera. Seis operadores relacionales son disponibles: &lt;, &gt;, &lt;=, &gt;=, == y ~=. La funci&oacute;n de escal&oacute;n unitario se define f&aacute;cilmente usando el operador relacional &gt;=</p>
<pre class="codeinput">u = @(t) 1.0.*(t&gt;=0);
</pre>
<p>Cualquier funci&oacute;n con una discontinuidad de salto, como el escal&oacute;n unitario, es dif&iacute;cil de trazar. Considere la posibilidad de trazar u(t) usando t = (-2:2).</p>
<pre class="codeinput">t = (-2:2); plot(t,u(t));
xlabel(<span class="string">'t&rsquo;); ylabel(&rsquo;u(t)'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_03.png" alt=""> <p>Dos problemas importantes son evidentes en el gr&aacute;fico resultante, que se muestra en la figura 1.48. Primero, MATLAB escala autom&aacute;ticamente los ejes del gr&aacute;fico para vincular estrechamente los datos. En este caso, esto normalmente La caracter&iacute;stica deseable oscurece la mayor parte de la trama. En segundo lugar, MATLAB conecta los datos del trazado con l&iacute;neas, haciendo que una verdadera discontinuidad de salto sea dif&iacute;cil de lograr. La resoluci&oacute;n gruesa del vector t enfatiza el efecto al mostrar una l&iacute;nea inclinada err&oacute;nea entre t = &minus;1 y t = 0. El primer problema se corrige ampliando verticalmente el cuadro delimitador con el eje dominio. El segundo problema se reduce, pero no se elimina, sumando puntos al vector t.</p>
<pre class="codeinput">t = (-2:0.01:2); plot(t,u(t));
 xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'u(t)'</span>);
 axis([-2 2 -0.1 1.1]);
</pre>
<img vspace="5" hspace="5" src="untitled2_04.png" alt=""> <p>El argumento vectorial de cuatro elementos del eje especifica el eje x m&iacute;nimo, el eje x m&aacute;ximo y el eje y. m&iacute;nimo y m&aacute;ximo del eje y, respectivamente. Los resultados mejorados se muestran en la figura 1.49. Los operadores relacionales se pueden combinar usando AND l&oacute;gico, O l&oacute;gico y negaci&oacute;n l&oacute;gica: &amp;, | y ~, respectivamente. Por ejemplo, (t&gt;0)&amp;(t&lt;1) y ~((t&lt;=0)|(t&gt;=1)) prueban si 0 &lt; t &lt; 1. Para demostrarlo, considere definir y trazar el pulso unitario p(t) = u(t) &minus; u(t &minus; 1), como se muestra en Figura 1.50</p>
<pre class="codeinput"> p = @(t) 1.0.*((t&gt;=0)&amp;(t&lt;1));
t = (-1:0.01:2); plot(t,p(t));
xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'p(t) = u(t)-u(t-1)'</span>);
axis([-1 2 -.1 1.1]);
</pre>
<img vspace="5" hspace="5" src="untitled2_05.png" alt=""> <p>Dado que las funciones an&oacute;nimas se pueden construir utilizando otras funciones an&oacute;nimas, podr&iacute;amos Hemos utilizado nuestra funci&oacute;n an&oacute;nima de paso unitario previamente definida para definir p(t) como p = @(t) u(t)-u(t-1); Para operandos escalares, MATLAB tambi&eacute;n admite dos construcciones l&oacute;gicas de cortocircuito. A El AND l&oacute;gico de cortocircuito se realiza mediante &amp;&amp;, y el OR l&oacute;gico de cortocircuito se realiza mediante usando. Los operadores l&oacute;gicos de cortocircuito suelen ser m&aacute;s eficientes que los operadores l&oacute;gicos tradicionales. porque prueban la segunda parte de la expresi&oacute;n s&oacute;lo cuando es necesario. Es decir, cuando escalar la expresi&oacute;n A se encuentra falsa en (A&amp;&amp;B), la expresi&oacute;n escalar B no se eval&uacute;a, ya que un resultado falso ya est&aacute; garantizado. De manera similar, la expresi&oacute;n escalar B no se eval&uacute;a cuando la expresi&oacute;n escalar A es encontrado verdadero en (A||B), ya que ya se garantiza un resultado verdadero.</p>
<h2 id="34">1.11-3 Visualizaci&oacute;n de operaciones en la variable independiente</h2>
<p>Com&uacute;nmente se encuentran dos operaciones sobre la variable independiente de una funci&oacute;n: desplazamiento y escalada. Las funciones an&oacute;nimas son muy adecuadas para investigar ambas operaciones. Considere g(t) = f(t)u(t) = e&minus;t cos(2πt)u(t), una versi&oacute;n causal de f(t). MATLAB f&aacute;cilmente multiplica funciones an&oacute;nimas. Por lo tanto, creamos g(t) multiplicando nuestras funciones an&oacute;nimas. para f(t) y u(t).</p>
<pre class="codeinput"> g = @(t) f(t).*u(t);
</pre>
<p>Una operaci&oacute;n combinada de cambio y escala est&aacute; representada por g(at + b), donde a y b son constantes reales arbitrarias. Como ejemplo, considere graficar g(2t +1) sobre (&minus;2 &le; t &le; 2). Con a = 2, la funci&oacute;n se comprime por un factor de 2, lo que da como resultado el doble de oscilaciones por unidad t. A&ntilde;adiendo la condici&oacute;n b &gt; 0 desplaza la forma de onda hacia la izquierda. Dada la funci&oacute;n an&oacute;nima g, una gr&aacute;fica precisa es casi trivial de obtener</p>
<pre class="codeinput"> t = (-2:0.01:2);
plot(t,g(2*t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'g(2t+1)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="untitled2_06.png" alt=""> <p>La Figura 1.51 confirma la compresi&oacute;n esperada de la forma de onda y el desplazamiento hacia la izquierda. Como comprobaci&oacute;n final, tenga en cuenta esa funci&oacute;n g(&middot;) se activa cuando el argumento de entrada es cero. Por lo tanto, g(2t + 1) deber&iacute;a activarse cuando 2t +1 = 0 o en t = &minus;0.5, hecho confirmado nuevamente por la figura 1.51. A continuaci&oacute;n, considere graficar g(&minus;t + 1) sobre (&minus;2 &le; t &le; 2). Como a &lt; 0, la forma de onda ser&aacute; reflejado. Agregar la condici&oacute;n b &gt; 0 desplaza la forma de onda final hacia la derecha.</p>
<pre class="codeinput">plot(t,g(-t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'g(-t+1)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="untitled2_07.png" alt=""> <p>La figura 1.52 confirma tanto la reflexi&oacute;n como el desplazamiento a la derecha. Hasta este punto, las Figs. 1,51 y 1,52 podr&iacute;an esbozarse razonablemente a mano. Considere la posibilidad de trazar la funci&oacute;n m&aacute;s complicada h(t) = g(2t + 1) + g(&minus;t + 1) sobre (&minus;2 &le; t &le; 2) (figura 1.53); un Un boceto a mano preciso ser&iacute;a bastante dif&iacute;cil. Con MATLAB, el trabajo es mucho menos engorroso.</p>
<pre class="codeinput">plot(t,g(2*t+1)+g(-t+1)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'h(t)'</span>); grid;
</pre>
<img vspace="5" hspace="5" src="untitled2_08.png" alt=""> <h2 id="43">1.11-4 Numerical Integration and Estimating Signal Energy</h2>
<p>Las se&ntilde;ales interesantes suelen tener representaciones matem&aacute;ticas no triviales. Computar la energ&iacute;a de la se&ntilde;al, que implica integrar el cuadrado de estas expresiones, puede ser una tarea desalentadora. Afortunadamente, Muchas integrales dif&iacute;ciles se pueden estimar con precisi&oacute;n mediante t&eacute;cnicas de integraci&oacute;n num&eacute;rica. Incluso si la integraci&oacute;n parece simple, la integraci&oacute;n num&eacute;rica proporciona una buena manera de verificar resultados anal&iacute;ticos. Para empezar, considere la se&ntilde;al simple x(t) = e&minus;t (u(t)-u(t-1)). La energ&iacute;a de x(t) se expresa como Ex = integral de &minus;&infin; a &infin; de <tt>x(t)</tt> 2 dt = integrla de 0 a 1 de e^&minus;2t dt. La integraci&oacute;n produce Ex = 0,5(1 &minus; e&minus;2) &asymp; 0,4323. La energ&iacute;a La integral tambi&eacute;n se puede evaluar num&eacute;ricamente. La figura 1.27 ayuda a ilustrar el m&eacute;todo simple de aproximaci&oacute;n rectangular: eval&uacute;e el integrando en puntos separados uniformemente por t, multiplique cada uno por t para calcular las &aacute;reas del rect&aacute;ngulo y luego sumar todos los rect&aacute;ngulos. Primero, creamos la funci&oacute;n. x(t)</p>
<pre class="codeinput"> x = @(t) exp(-t).*((t&gt;=0)&amp;(t&lt;1));
</pre>
<p>Con ∆t = 0,01, se crea un vector de tiempo adecuado</p>
<pre class="codeinput"> t = (0:0.01:1);
</pre>
<p>El resultado final se computa usando el comando sum</p>
<pre class="codeinput">  E_x = sum(x(t).*x(t)*0.01);
</pre>
<p>El resultado no es perfecto, pero con un error relativo del 1% est&aacute; cerca. Reduciendo t, la aproximaci&oacute;n es mejorado. Por ejemplo, ∆t = 0,001 produce E_x = 0,4328, o un error relativo del 0,1%. Aunque es f&aacute;cil de visualizar, la aproximaci&oacute;n rectangular no es la mejor integraci&oacute;n num&eacute;rica t&eacute;cnica. La funci&oacute;n quad de MATLAB implementa una mejor t&eacute;cnica de integraci&oacute;n num&eacute;rica llamada cuadratura de Simpson adaptativa recursiva.&dagger; Para operar, quad requiere una funci&oacute;n que describa el integrando, el l&iacute;mite inferior de integraci&oacute;n y el l&iacute;mite superior de integraci&oacute;n. Observe que no es necesario especificar. Para utilizar quad para estimar Ex, primero se debe describir el integrando</p>
<pre class="codeinput">x_squared = @(t) x(t).*x(t);
E_x = integral(x_squared,0,1);
</pre>
<p>En este caso, el error relativo es &minus;0,0026%. Se pueden utilizar las mismas t&eacute;cnicas para estimar la energ&iacute;a de se&ntilde;ales m&aacute;s complejas. Considerar g(t), definido anteriormente. La energ&iacute;a se expresa como Eg = $ &infin; 0 e&minus;2t cos2 (2πt)dt. Una soluci&oacute;n de forma cerrada existe, pero requiere algo de esfuerzo. MATLAB proporciona una respuesta m&aacute;s r&aacute;pida</p>
<pre class="codeinput"> g_squared = @(t) g(t).*g(t);
</pre>
<p>Aunque el l&iacute;mite superior de integraci&oacute;n es infinito, la envolvente que decae exponencialmente asegura g(t) es efectivamente cero mucho antes de t = 100. Por lo tanto, se utiliza un l&iacute;mite superior de t = 100 junto con ∆t = 0,001.</p>
<pre class="codeinput"> t = (0:0.001:100);
E_g = sum(g_squared(t)*0.001);
</pre>
<p>Un poco mejor obtenida con</p>
<pre class="codeinput">E_g = quad(g_squared,0,100);
</pre>
<h2 id="59">1.12 SUMMARY</h2>
<p>Una se&ntilde;al es un conjunto de datos o informaci&oacute;n. Un sistema procesa se&ntilde;ales de entrada para modificarlas o extraerlas. informaci&oacute;n adicional de ellos para producir se&ntilde;ales de salida (respuesta). Se puede formar un sistema de componentes f&iacute;sicos (realizaci&oacute;n de hardware), o puede ser un algoritmo que calcula una salida se&ntilde;al a partir de una se&ntilde;al de entrada (realizaci&oacute;n de software). Una medida conveniente del tama&ntilde;o de una se&ntilde;al es su energ&iacute;a, si es finita. Si la energ&iacute;a de la se&ntilde;al es infinito, la medida adecuada es su potencia, si existe. La potencia de la se&ntilde;al es el promedio de tiempo de su energ&iacute;a (promediada durante todo el intervalo de tiempo desde &minus;&infin; hasta &infin;). Para se&ntilde;ales peri&oacute;dicas, el tiempo el promedio s&oacute;lo debe realizarse durante un per&iacute;odo en vista de la repetici&oacute;n peri&oacute;dica de la se&ntilde;al. La potencia de la se&ntilde;al tambi&eacute;n es igual al valor medio cuadr&aacute;tico de la se&ntilde;al (promediado durante todo el tiempo). intervalo de t = &minus;&infin; a &infin;). Las se&ntilde;ales se pueden clasificar de varias formas.</p>
<div>
<ul>
<li>1. Se especifica una se&ntilde;al de tiempo continuo para un continuo de valores de la variable independiente. (como el tiempo t). Una se&ntilde;al de tiempo discreto se especifica s&oacute;lo en un conjunto finito o contable de instantes de tiempo.</li>
<li>2. Una se&ntilde;al anal&oacute;gica es una se&ntilde;al cuya amplitud puede tomar cualquier valor en un continuo. En Por otro lado, una se&ntilde;al cuyas amplitudes s&oacute;lo pueden tomar un n&uacute;mero finito de valores es una se&ntilde;al digital. Los t&eacute;rminos tiempo discreto y tiempo continuo califican la naturaleza de una se&ntilde;al. a lo largo del eje del tiempo (eje horizontal). Los t&eacute;rminos anal&oacute;gico y digital, por otro lado, calificar la naturaleza de la amplitud de la se&ntilde;al (eje vertical).</li>
<li>3. Una se&ntilde;al peri&oacute;dica x(t) se define por el hecho de que x(t) = x(t +T0) para alg&uacute;n T0. El mas peque&ntilde;o El valor positivo de T0 para el cual se satisface esta relaci&oacute;n se denomina per&iacute;odo fundamental. Una se&ntilde;al peri&oacute;dica permanece sin cambios cuando se desplaza un m&uacute;ltiplo entero de su per&iacute;odo. Una se&ntilde;al peri&oacute;dica x(t) puede generarse mediante una extensi&oacute;n peri&oacute;dica de cualquier segmento contiguo de x(t) de duraci&oacute;n T0. Finalmente, una se&ntilde;al peri&oacute;dica, por definici&oacute;n, debe existir en todo el intervalo de tiempo &minus;&infin; &lt; t &lt; &infin;. Una se&ntilde;al es aperi&oacute;dica si no es peri&oacute;dica.</li>
<li>4. Una se&ntilde;al eterna comienza en t = &minus;&infin; y contin&uacute;a para siempre hasta t = &infin;. Por lo tanto, peri&oacute;dico Las se&ntilde;ales son se&ntilde;ales eternas. Una se&ntilde;al causal es una se&ntilde;al que es cero para t &lt; 0.</li>
<li>5. Una se&ntilde;al con energ&iacute;a finita es una se&ntilde;al de energ&iacute;a. De manera similar, una se&ntilde;al con finito y distinto de cero La potencia (valor cuadr&aacute;tico medio) es una se&ntilde;al de potencia. Una se&ntilde;al puede ser una se&ntilde;al de energ&iacute;a o una se&ntilde;al de potencia, pero no ambas. Sin embargo, hay se&ntilde;ales que no son ni energ&iacute;a ni potencia. se&ntilde;ales.</li>
<li>6. Una se&ntilde;al cuya descripci&oacute;n f&iacute;sica se conoce completamente en forma matem&aacute;tica o gr&aacute;fica. La forma es una se&ntilde;al determinista. Una se&ntilde;al aleatoria se conoce s&oacute;lo en t&eacute;rminos de su probabilidad. descripci&oacute;n como valor medio o valor cuadr&aacute;tico medio, en lugar de por su valor matem&aacute;tico o forma gr&aacute;fica.</li>
</ul>
</div>
<p>Una se&ntilde;al x(t) retrasada T segundos (desplazada a la derecha) se puede expresar como x(t &minus; T); en el otro Por otro lado, x(t) avanzado por T (desplazado a la izquierda) es x(t + T). Una se&ntilde;al x(t) comprimida en el tiempo por un factor a(a &gt; 1) se expresa como x(at); por otro lado, la misma se&ntilde;al ampliada en el tiempo por el factor a(a &gt; 1) es x(t/a). La se&ntilde;al x(t) cuando se invierte el tiempo se puede expresar como x(&minus;t). La funci&oacute;n de paso unitario u(t) es muy &uacute;til para representar se&ntilde;ales causales y se&ntilde;ales con diferentes descripciones matem&aacute;ticas en diferentes intervalos. En la definici&oacute;n cl&aacute;sica (Dirac), la funci&oacute;n de impulso unitario δ(t) se caracteriza por un &aacute;rea unitaria y se concentra en un solo instante t = 0. La funci&oacute;n de impulso tiene un muestreo (o tamizado) propiedad, que establece que el &aacute;rea bajo el producto de una funci&oacute;n con un impulso unitario es igual a el valor de esa funci&oacute;n en el instante en que se localiza el impulso (suponiendo que la funci&oacute;n ser continuo en el lugar del impulso). En el enfoque moderno, la funci&oacute;n de impulso se considera como una funci&oacute;n generalizada y est&aacute; definida por la propiedad de muestreo. La funci&oacute;n exponencial est, donde s es compleja, abarca una gran clase de se&ntilde;ales que incluye una constante, una exponencial mon&oacute;tona, una sinusoide y una sinusoide que var&iacute;a exponencialmente. Una se&ntilde;al real que es sim&eacute;trica con respecto al eje vertical (t = 0) es una funci&oacute;n par del tiempo, y una se&ntilde;al real que es antisim&eacute;trica con respecto al eje vertical es una funci&oacute;n impar del tiempo. El El producto de una funci&oacute;n par y una funci&oacute;n impar es una funci&oacute;n impar. Sin embargo, el producto de una funci&oacute;n par y una funci&oacute;n par o una funci&oacute;n impar y una funci&oacute;n impar es una funci&oacute;n par. El &aacute;rea bajo una funci&oacute;n impar desde t = &minus;a hasta a es siempre cero independientemente del valor de a. En por otro lado, el &aacute;rea bajo una funci&oacute;n par desde t = &minus;a hasta a es dos veces el &aacute;rea bajo la misma funci&oacute;n desde t = 0 hasta a (o desde t = &minus;a hasta 0). Cada se&ntilde;al se puede expresar como una suma de funciones pares e impares del tiempo. Un sistema procesa se&ntilde;ales de entrada para producir se&ntilde;ales de salida (respuesta). La entrada es la causa, y el resultado es su efecto. En general, la producci&oacute;n se ve afectada por dos causas: las condiciones internas del sistema (como las condiciones iniciales) y la entrada externa. Los sistemas se pueden clasificar de varias maneras.</p>
<div>
<ul>
<li>1. Los sistemas lineales se caracterizan por la propiedad de linealidad, que implica superposici&oacute;n; si varias causas (como diversas entradas y condiciones iniciales) act&uacute;an sobre un sistema lineal, El resultado total (respuesta) es la suma de las respuestas de cada causa, suponiendo que todas las causas restantes est&aacute;n ausentes. Un sistema es no lineal si no se cumple la superposici&oacute;n.</li>
<li>2. En sistemas invariantes en el tiempo, los par&aacute;metros del sistema no cambian con el tiempo. Los par&aacute;metros de Los sistemas de par&aacute;metros variables en el tiempo cambian con el tiempo.</li>
<li>3. Para sistemas sin memoria (o instant&aacute;neos), la respuesta del sistema en cualquier instante t depende s&oacute;lo en el valor de la entrada en t. Para sistemas con memoria (tambi&eacute;n conocidos como sistemas di&aacute;micos), la respuesta del sistema en cualquier instante t depende no s&oacute;lo del valor presente de la entrada, sino tambi&eacute;n en los valores pasados de la entrada (valores antes de t).</li>
<li>4. Por el contrario, si la respuesta del sistema en t tambi&eacute;n depende de los valores futuros de la entrada (valores de entrada m&aacute;s all&aacute; de t), el sistema es no causal. En los sistemas causales, la respuesta no depende sobre los valores futuros de la entrada. Debido a la dependencia de la respuesta del futuro. valores de entrada, el efecto (respuesta) de los sistemas no causales ocurre antes que la causa. Cuando la variable independiente es el tiempo (sistemas temporales), los sistemas no causales son prof&eacute;ticos sistemas y, por lo tanto, irrealizables, aunque una aproximaci&oacute;n cercana es posible con algunos retraso en la respuesta. Sistemas no causales con variables independientes distintas del tiempo. (por ejemplo, el espacio) son realizables.</li>
<li>5. Los sistemas cuyas entradas y salidas son se&ntilde;ales de tiempo continuo son se&ntilde;ales de tiempo continuo. sistemas; Los sistemas cuyas entradas y salidas son se&ntilde;ales de tiempo discreto son se&ntilde;ales de tiempo discreto. sistemas. Si se muestrea una se&ntilde;al de tiempo continuo, la se&ntilde;al resultante es una se&ntilde;al de tiempo discreto. se&ntilde;al. Podemos procesar una se&ntilde;al de tiempo continuo procesando las muestras de la se&ntilde;al. con un sistema de tiempo discreto.</li>
<li>6. Son sistemas anal&oacute;gicos los sistemas cuyas entradas y salidas sean se&ntilde;ales anal&oacute;gicas; Esos que Las entradas y salidas son se&ntilde;ales digitales, son sistemas digitales.</li>
<li>7. Si podemos obtener la entrada x(t) a partir de la salida y(t) de un sistema S mediante alguna operaci&oacute;n, Se dice que el sistema S es invertible. De lo contrario, el sistema no es invertible.</li>
<li>8. Un sistema es estable si una entrada limitada produce una salida limitada. Esto define lo externo. Estabilidad porque se puede determinar a partir de mediciones en los terminales externos. del sistema. La estabilidad externa tambi&eacute;n se conoce como estabilidad en el BIBO. (entrada limitada/salida limitada). La estabilidad interna, que se analiza m&aacute;s adelante en el cap. 2, es medido en t&eacute;rminos del comportamiento interno del sistema. El modelo del sistema derivado del conocimiento de la estructura interna del sistema es su descripci&oacute;n interna. Por el contrario, una descripci&oacute;n externa es una representaci&oacute;n de un sistema tal como se ve. desde sus terminales de entrada y salida; se puede obtener aplicando una entrada conocida y midiendo la salida resultante. En la mayor&iacute;a de los sistemas pr&aacute;cticos, una descripci&oacute;n externa de un sistema es tan obtenido es equivalente a su descripci&oacute;n interna. A veces, sin embargo, la descripci&oacute;n externa no logra describir adecuadamente el sistema. Tal es el caso de los llamados incontrolables o inobservables. sistemas. Un sistema tambi&eacute;n puede describirse en t&eacute;rminos de cierto conjunto de variables clave llamadas variables de estado. En esta descripci&oacute;n, un sistema de en&eacute;simo orden se puede caracterizar por un conjunto de N sistemas simult&aacute;neos de primer orden. ecuaciones diferenciales en N variables de estado. Las ecuaciones de estado de un sistema representan una ecuaci&oacute;n interna que describe ese sistema.</li>
</ul>
</div>
<h2 id="60">Problema 2</h2>
<p>1.2-2 For the signal x(t) illustrated in Fig. P1.2-2,sketch</p>
<div>
<ul>
<li>(a) x(t &minus;4)</li>
<li>(b) x(t/1.5)</li>
<li>(c) x(&minus;t)</li>
<li>(d) x(2t &minus;4)</li>
<li>(e) x(2&minus;t)</li>
</ul>
</div>
<p>Generando la funci&oacute;n original Iniciamos recreando la se&ntilde;al, mostrada en la grafica que muestra "Lathi" Hacemos anonima la funcion y la guardamos en la varibale "y". Continuamente proponemos un intervalo adecuado y se pueda representar en la grafica correctamente.</p>
<pre class="codeinput">sympref(<span class="string">'HeavisideAtOrigin'</span>,0);
y = @(t) (-t.*(heaviside(t+4)) + 2*t.*(heaviside(t))).*heaviside(-t+2);
t= -7:0.01:7;
plot(t,y(t)); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'y(t)'</span>);
title(<span class="string">'Fig. P1.2-2'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_09.png" alt=""> <h2 id="62">a) x(t-4)</h2>
<p>Como se observa en el inciso "A", podemos ver que se trata de una traslacion horizontal en 4 unidades. Por lo que simplemente realizamos la traslacion y la graficamos.</p>
<pre class="codeinput">A=y(t-4);
plot(t,A); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'y(t-4)'</span>);
title(<span class="string">'Figura A'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_10.png" alt=""> <h2 id="64">b) x(t/1.5)</h2>
<p>En el inciso "B" podemos percatarnos que ahora se trata de una division entre la variable "t", pero recordando un poco sobre el comportamiento de las funciones, tenemos que al dividir la variable de la funcion, se ancha la amplitud de manera horizontal sin modificar la altura de la se&ntilde;al original. Por lo que:</p>
<pre class="codeinput">B=y(t./1.5);
plot(t,B); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'y(t/1.5'</span>);
title(<span class="string">'Figura B'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_11.png" alt=""> <p>Como se determino inicialmente, la funcion se ampli de manera horizontal en un valor de 1.5</p>
<h2 id="67">c)x(&minus;t)</h2>
<p>En el inciso "C" se muestra la funcion original, con la unica diferencia que tiene un signo negativo en la "x", esto nos representa una inversion horizontal de la funcion original, es decir, realiza un efecto espejo.</p>
<pre class="codeinput">C=y(-t);
plot(t,C); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'y(-t)'</span>);
title(<span class="string">'Figura C'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_12.png" alt=""> <p>Tal y como se argumento es una inversion horizontal de la funcion original.</p>
<h2 id="70">d) x(2t &minus;4)</h2>
<p>Podemos ver que ahora se presentan dos cambios, una compresion y una traslacion, ambas de manera horizontal, obsevando se deduce que se comprime entre dos, respecto a la funcion original y ademas se traslada 4 unidades.</p>
<pre class="codeinput">D= y(2.*t-4);
plot(t,D); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'y(2t-4)'</span>);
title(<span class="string">'Figura D'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_13.png" alt=""> <h2 id="72">e) x(2&minus;t)</h2>
<p>En el inciso "E" se muestra una "t" negativa y un 2 positivo, reordenando vemos x(-t+2), por lo cual se trata de una inversion y una traslacion, ambas horizontales, la traslacion es de dos unidades.</p>
<pre class="codeinput">E=y(2-t);
plot(t,E); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'y(2-t)'</span>);
title(<span class="string">'Figura E'</span>);
</pre>
<img vspace="5" hspace="5" src="untitled2_14.png" alt=""> <h2 id="73">Problema 3</h2>
<p>Proporcionar c&oacute;digo MATLAB y resultados que tracen la porci&oacute;n impar xo(t) de la funci&oacute;n x(t) = 2&minus;t cos(2πt)u(t&minus;π) en un intervalo de longitud adecuada utilizando un n&uacute;mero adecuado de puntos.</p>
<p>Para empezar, observamos que x(t) comienza en t = π. Dado que 2&minus;t decae a menos de 1/100 de su resistencia original en 7 segundos, es suficiente representar x(t) en t = 10.</p>
<p>Dado que xo(t) incluye x(t) y su reflexi&oacute;n, a el rango de tiempo adecuado para nuestra gr&aacute;fica es &minus;10 &le; t &le; 10.</p>
<pre class="codeinput"> u = @(t) 1.0*(t&gt;=0); t = -10:1/20:10;
</pre>
<p>Dado que cos(2πt) oscila un ciclo por segundo, a una densidad de trama de 20 puntos por segundo es suficiente para una trama de calidad razonable.</p>
<pre class="codeinput">x = @(t) 2.^(-t).*cos(2*pi*t).*u(t-pi); xo = @(t) (x(t)-x(-t))/2;
</pre>
<p>Usamos la funcion plot con las variables previamente designadas y graficamos:</p>
<pre class="codeinput"> plot(t,xo(t),<span class="string">'k-'</span>); xlabel(<span class="string">'t'</span>); ylabel(<span class="string">'x_o(t)'</span>); grid <span class="string">on</span>;
 axis([-10 10 -1/20 1/20]); set(gca,<span class="string">'xtick'</span>,[-10 -pi 0 pi 10]);
</pre>
<img vspace="5" hspace="5" src="untitled2_15.png" alt=""> <h2 id="81">Problema 4</h2>
<pre>Construye la grafica de</pre>
<p>
<img src="untitled2_eq18343799352459205464.png" alt="$$x(t) = \sum_{k=1}^{10} cos(2\pi k t)$$"></p>
<p>para cuatro rangos (figura 2x2). Los ejes deben mostrarse en el origen adem&aacute;s de la edici&oacute;n de su preferencia.</p>
<p>A continuaci&oacute;n se muestra la grafica:</p>
<p>
<img vspace="5" hspace="5" src="grafica.PNG" alt=""> </p>
<h2 id="83">Problema 5</h2>
<p>Resuelve el problema 1.11-3, agrega como inciso (e) la gr&aacute;fica de <img src="untitled2_eq12659395712222829305.png" alt="$x(t)$"> para <img src="untitled2_eq16434444273656135249.png" alt="$t\in[-10,10]$"></p>
<h2 id="84">Problema 6</h2>
<p>El resultado de esta aplicacion se puede observar en la siguiente imagen, en la cual se ense&ntilde;a como al darle una funcion "t", la grafica y selecciona los intervalos dados, en este caso entre -5 y 2. Donde se puede mostrar que corta a la funcion justo en esos valores de t</p>
<p>
<img vspace="5" hspace="5" src="Problema_6.PNG" alt=""> </p>
<p>Primeramente para explicar, las lineas de codigo tenemos que mostrar los componentes que utilizamos, en primer lugar usamos Axes (Para graficar), Edit Field text(Para ingresar las funciones), Edit Field Numerico (Para ingresar los limites de la funcion y variaciones max y min), Push Button (Para que inicie el proceso de graficacion), Area Text (mostrar raices).</p>
<p>
<img vspace="5" hspace="5" src="Problema_6_b.PNG" alt=""> </p>
<p>Desenglozando el codigo vamos al apartado de callbacks del push button para que todo gire en torno al presionarlo. Primero vamos a leer los caracteres que tiene la funcion que ingresa el usuario, especificamente los valores de cada uno. Despues tenemos que convertir esa funcion en una variable simbolica, llamando a las funciones que nos proporciona MATLAB. Al final describimos la variable simbolica en un vector, despues calulamos las raices del polinomio Y ese valor de las raices las enviamos al area de texto (esto sirve para identificar partes reales de imaginarias). Siguiendo tenemos que programar la seccion para establecer limites de maximos y minimos en valores de x &amp; y para poder tener un campo especifico de la funcion, tomados en intervalos. Asi mismo, damos en el intervalo de integracion de 100 puntos, para que en la grafica se vea fluida la funcion ya graficada. Para graficar haremos uso de la funcion plot, donde se debe especificar que se dibuja en el panel de la grafica. Despues colocamos dos if's en el cual se define los valores de los ejes en x&amp;y, recordando que se reciben valores infinitos, y con ayuda del if, se calcularan automaticamente, con ayuda de los valores maximos de t y l.</p>
<p>
<img vspace="5" hspace="5" src="Problema_6_a.PNG" alt=""> </p>
<h2 id="91">REFERENCIAS</h2>
<div>
<ul>
<li>1. Papoulis, A., La integral de Fourier y sus aplicaciones. McGraw-Hill, Nueva York, 1962.</li>
<li>2. Mason, S. J., Circuitos, se&ntilde;ales y sistemas electr&oacute;nicos. Wiley, Nueva York, 1960.</li>
<li>3. Kailath, T., Sistemas lineales. Prentice-Hall, Englewood Cliffs, Nueva Jersey, 1980.</li>
<li>4. Lathi, B. P., Se&ntilde;ales y sistemas. Prensa de Berkeley-Cambridge, Carmichael, CA, 1987</li>
</ul>
</div>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Práctica 3: Señales en tiempo continuo
%
%
%% Integrantes
%
% * Hernandez López Daniel
% * Jaime Hernández Jaime
% * Ojeda Salgado Rodrigo
% * Reyes Guevara Nathalia
% * Riveros Valencia Javier Alejandro

%% Objetivos de la Práctica
%
% * Manipulación básica de MATLAB
% * Gráficas de señales reales y complejas continuas
% * Transformación de señales continuas (escalamientos y traslaciones)
% * Calculo de energía y potencia de señales continuas
%% Introducción
% Como evidencia de la investigaciòn en Python se grafica lo siguiente:
%%
% 
% <<descarga.PNG>>
% 
% El codigo con el que se genero la grafica pues consultarse en este enlace <https://colab.research.google.com/drive/12C3_0FH1c_eUslcJhYHQlChPufOYX8Cj?usp=sharing> 
%% Desarrollo
% 
%

%% Problema 1
%% 1.11 MATLAB: WORKING WITH FUNCTIONS
%  El trabajo con funciones es fundamental para las aplicaciones de señales y sistemas. MATLAB proporciona varios métodos para definir y evaluar funciones. Por lo tanto, la comprensión y el uso competente de estos métodos son necesarios y beneficiosos.
%% 1.11-1 Anonymous Functions
% Muchas funciones sencillas se representan de forma más cómoda mediante el uso de MATLAB anonymous
% Funciones. Una función anónima proporciona una representación simbólica de una función definida en
% términos de operadores, funciones u otras funciones anónimas de MATLAB. Por ejemplo, considere
% Definición de la sinusoide exponencialmente amortiguada f(t) = e−t cos(2πt)
%%
 f = @(t) exp(-t).*cos(2*pi*t) ;
%%
% En este contexto, el símbolo @ identifica la expresión como una función anónima, que se asigna  un nombre de f. Los paréntesis que siguen al símbolo @ se utilizan para identificar la función independiente. variables (argumentos de entrada), que en este caso es la única variable de tiempo t. Argumentos de entrada, como
% como t, son locales de la función anónima y no están relacionados con ninguna variable del espacio de trabajo con la
% mismos nombres.
%
% Una vez definida, f(t) se puede evaluar simplemente pasando los valores de entrada de interés. Para
% ejemplo,
%%
 t = 0; f(t)
 %%
% ans = 1
% evalúa f(t) en t = 0, confirmando el resultado esperado de la unidad. El mismo resultado se obtiene mediante
% pasando t = 0 directamente.
%%
f(0)
%%
% respuesta = 1
% Las entradas vectoriales permiten la evaluación de múltiples valores simultáneamente. Considere la tarea
% de trazar f(t) en el intervalo (−2 ≤ t ≤ 2). El comportamiento de la función bruta es claro: f(t) debería
% oscilar cuatro veces con una envolvente en decadencia. Dado que los bocetos precisos a mano son engorrosos,
% Los gráficos generados por MATLAB son una alternativa atractiva. Como ilustra el siguiente ejemplo, el cuidado
% Se deben tomar medidas para garantizar resultados confiables.
%
% Supongamos que se elige el vector t para incluir solo los números enteros contenidos en (−2 ≤ t ≤ 2), es decir,
% [-2,-1, 0, 1, 2].
%%
 t = (-2:2);
%%
% Esta entrada vectorial se evalúa para formar una salida vectorial.
%%
 f(t)
 %%
% respuesta = 7,3891 2,7183 1,0000 0,3679 0,135
%
% El comando plot grafica el resultado, que se muestra en la figura 1.46.
%%
plot(t,f(t));
xlabel('t'); ylabel('f(t)'); grid;
%%
% Las líneas de cuadrícula, agregadas mediante el comando de cuadrícula, ayudan a identificar las características. Desafortunadamente, el
% El gráfico no ilustra el comportamiento oscilatorio esperado. Se requieren más puntos para adecuadamente
% representar f(t).
%
% La pregunta entonces es ¿cuántos puntos son suficientes?† Si se eligen muy pocos puntos, la información
% está perdido. Si se eligen demasiados puntos, se desperdicia memoria y tiempo. Se necesita un equilibrio.
% Para funciones oscilatorias, normalmente es adecuado trazar de 20 a 200 puntos por oscilación. Para el presente
% En este caso, se elige t para dar 100 puntos por oscilación.
%
%%
t = (-2:0.01:2);
%%
% Nuevamente, la función se evalúa y traza:
%% 
plot(t,f(t));
xlabel('t’); ylabel(’f(t)'); grid
%%
%% 1.11-2 Relational Operators and the Unit Step Function
% La función escalón unitario u(t) surge naturalmente en muchas situaciones prácticas. Por ejemplo, un paso unitario puede
% Modelar el acto de encender un sistema. Con la ayuda de operadores relacionales, funciones anónimas.
% puede representar la función de paso unitario.
% En MATLAB, un operador relacional compara dos elementos. Si la comparación es cierta, una verdad lógica.
% (1) se devuelve. Si la comparación es falsa, se devuelve un falso lógico (0). A veces llamado indicador
% funciones, los operadores relacionales indican si una condición es verdadera. Seis operadores relacionales son
% disponibles: <, >, <=, >=, == y ~=.
% La función de escalón unitario se define fácilmente usando el operador relacional >=
%%
u = @(t) 1.0.*(t>=0);
%%
% Cualquier función con una discontinuidad de salto, como el escalón unitario, es difícil de trazar. Considere la posibilidad de trazar
% u(t) usando t = (-2:2).
%%
t = (-2:2); plot(t,u(t)); 
xlabel('t’); ylabel(’u(t)');
%%
% Dos problemas importantes son evidentes en el gráfico resultante, que se muestra en la figura 1.48. Primero,
% MATLAB escala automáticamente los ejes del gráfico para vincular estrechamente los datos. En este caso, esto normalmente
% La característica deseable oscurece la mayor parte de la trama. En segundo lugar, MATLAB conecta los datos del trazado con líneas,
% haciendo que una verdadera discontinuidad de salto sea difícil de lograr. La resolución gruesa del vector t enfatiza
% el efecto al mostrar una línea inclinada errónea entre t = −1 y t = 0.
% El primer problema se corrige ampliando verticalmente el cuadro delimitador con el eje
% dominio. El segundo problema se reduce, pero no se elimina, sumando puntos al vector t.
%%
t = (-2:0.01:2); plot(t,u(t));
 xlabel('t'); ylabel('u(t)');
 axis([-2 2 -0.1 1.1]);
 %%
% El argumento vectorial de cuatro elementos del eje especifica el eje x mínimo, el eje x máximo y el eje y.
% mínimo y máximo del eje y, respectivamente. Los resultados mejorados se muestran en la figura 1.49.
% Los operadores relacionales se pueden combinar usando AND lógico, O lógico y negación lógica: &,
% | y ~, respectivamente. Por ejemplo, (t>0)&(t<1) y ~((t<=0)|(t>=1)) prueban si 0 < t < 1.
% Para demostrarlo, considere definir y trazar el pulso unitario p(t) = u(t) − u(t − 1), como se muestra en
% Figura 1.50
%%
 p = @(t) 1.0.*((t>=0)&(t<1));
t = (-1:0.01:2); plot(t,p(t));
xlabel('t'); ylabel('p(t) = u(t)-u(t-1)');
axis([-1 2 -.1 1.1]);
%%
% Dado que las funciones anónimas se pueden construir utilizando otras funciones anónimas, podríamos
% Hemos utilizado nuestra función anónima de paso unitario previamente definida para definir p(t) como p = @(t)
% u(t)-u(t-1);
% Para operandos escalares, MATLAB también admite dos construcciones lógicas de cortocircuito. A
% El AND lógico de cortocircuito se realiza mediante &&, y el OR lógico de cortocircuito se realiza mediante
% usando ||. Los operadores lógicos de cortocircuito suelen ser más eficientes que los operadores lógicos tradicionales.
% porque prueban la segunda parte de la expresión sólo cuando es necesario. Es decir, cuando escalar
% la expresión A se encuentra falsa en (A&&B), la expresión escalar B no se evalúa, ya que un resultado falso
% ya está garantizado. De manera similar, la expresión escalar B no se evalúa cuando la expresión escalar A es
% encontrado verdadero en (A||B), ya que ya se garantiza un resultado verdadero.
%% 1.11-3 Visualización de operaciones en la variable independiente
% Comúnmente se encuentran dos operaciones sobre la variable independiente de una función: desplazamiento y
% escalada. Las funciones anónimas son muy adecuadas para investigar ambas operaciones.
% Considere g(t) = f(t)u(t) = e−t cos(2πt)u(t), una versión causal de f(t). MATLAB fácilmente
% multiplica funciones anónimas. Por lo tanto, creamos g(t) multiplicando nuestras funciones anónimas.
% para f(t) y u(t).
%%
 g = @(t) f(t).*u(t);
 %%
% Una operación combinada de cambio y escala está representada por g(at + b), donde a y b son
% constantes reales arbitrarias. Como ejemplo, considere graficar g(2t +1) sobre (−2 ≤ t ≤ 2). Con a = 2,
% la función se comprime por un factor de 2, lo que da como resultado el doble de oscilaciones por unidad t. Añadiendo
% la condición b > 0 desplaza la forma de onda hacia la izquierda. Dada la función anónima g, una gráfica precisa
% es casi trivial de obtener
%%
 t = (-2:0.01:2);
plot(t,g(2*t+1)); xlabel('t'); ylabel('g(2t+1)'); grid;
%%
% La Figura 1.51 confirma la compresión esperada de la forma de onda y el desplazamiento hacia la izquierda. Como comprobación final, tenga en cuenta
% esa función g(·) se activa cuando el argumento de entrada es cero. Por lo tanto, g(2t + 1) debería activarse
% cuando 2t +1 = 0 o en t = −0.5, hecho confirmado nuevamente por la figura 1.51.
% A continuación, considere graficar g(−t + 1) sobre (−2 ≤ t ≤ 2). Como a < 0, la forma de onda será
% reflejado. Agregar la condición b > 0 desplaza la forma de onda final hacia la derecha.
%%
plot(t,g(-t+1)); xlabel('t'); ylabel('g(-t+1)'); grid;
%%
% La figura 1.52 confirma tanto la reflexión como el desplazamiento a la derecha.
% Hasta este punto, las Figs. 1,51 y 1,52 podrían esbozarse razonablemente a mano. Considere la posibilidad de trazar
% la función más complicada h(t) = g(2t + 1) + g(−t + 1) sobre (−2 ≤ t ≤ 2) (figura 1.53); un
% Un boceto a mano preciso sería bastante difícil. Con MATLAB, el trabajo es mucho menos engorroso.
%%
plot(t,g(2*t+1)+g(-t+1)); xlabel('t'); ylabel('h(t)'); grid;
%%

%% 1.11-4 Numerical Integration and Estimating Signal Energy
% Las señales interesantes suelen tener representaciones matemáticas no triviales. Computar la energía de la señal,
% que implica integrar el cuadrado de estas expresiones, puede ser una tarea desalentadora. Afortunadamente,
% Muchas integrales difíciles se pueden estimar con precisión mediante técnicas de integración numérica.
% Incluso si la integración parece simple, la integración numérica proporciona una buena manera de verificar
% resultados analíticos.
% Para empezar, considere la señal simple x(t) = e−t
% (u(t)-u(t-1)). La energía de x(t) se expresa
% como Ex = integral de −∞ a ∞ de |x(t)|
% 2 dt = integrla de 0 a 1 de e^−2t dt. La integración produce Ex = 0,5(1 − e−2) ≈ 0,4323. La energía
% La integral también se puede evaluar numéricamente. La figura 1.27 ayuda a ilustrar el método simple de
% aproximación rectangular: evalúe el integrando en puntos separados uniformemente por t, multiplique
% cada uno por t para calcular las áreas del rectángulo y luego sumar todos los rectángulos. Primero, creamos la función.
% x(t)
%%
 x = @(t) exp(-t).*((t>=0)&(t<1));
 %%
% Con ∆t = 0,01, se crea un vector de tiempo adecuado
%%
 t = (0:0.01:1);
 %%
 % El resultado final se computa usando el comando sum
 %%
  E_x = sum(x(t).*x(t)*0.01);
 %%
 
%%
% El resultado no es perfecto, pero con un error relativo del 1% está cerca. Reduciendo t, la aproximación es
% mejorado. Por ejemplo, ∆t = 0,001 produce E_x = 0,4328, o un error relativo del 0,1%.
% Aunque es fácil de visualizar, la aproximación rectangular no es la mejor integración numérica
% técnica. La función quad de MATLAB implementa una mejor técnica de integración numérica
% llamada cuadratura de Simpson adaptativa recursiva.† Para operar, quad requiere una función que describa
% el integrando, el límite inferior de integración y el límite superior de integración. Observe que no
% es necesario especificar.
% Para utilizar quad para estimar Ex, primero se debe describir el integrando
%%
x_squared = @(t) x(t).*x(t);
E_x = integral(x_squared,0,1);
%%
% En este caso, el error relativo es −0,0026%.
% Se pueden utilizar las mismas técnicas para estimar la energía de señales más complejas. Considerar
% g(t), definido anteriormente. La energía se expresa como Eg = $ ∞
% 0 e−2t cos2 (2πt)dt. Una solución de forma cerrada
% existe, pero requiere algo de esfuerzo. MATLAB proporciona una respuesta más rápida
%%
 g_squared = @(t) g(t).*g(t);
%%
% Aunque el límite superior de integración es infinito, la envolvente que decae exponencialmente asegura
% g(t) es efectivamente cero mucho antes de t = 100. Por lo tanto, se utiliza un límite superior de t = 100 junto con
% ∆t = 0,001.
%%
 t = (0:0.001:100);
E_g = sum(g_squared(t)*0.001);
%%
% Un poco mejor obtenida con 
%%
E_g = quad(g_squared,0,100);
%%
%% 1.12 SUMMARY
% Una señal es un conjunto de datos o información. Un sistema procesa señales de entrada para modificarlas o extraerlas.
% información adicional de ellos para producir señales de salida (respuesta). Se puede formar un sistema
% de componentes físicos (realización de hardware), o puede ser un algoritmo que calcula una salida
% señal a partir de una señal de entrada (realización de software).
% Una medida conveniente del tamaño de una señal es su energía, si es finita. Si la energía de la señal es
% infinito, la medida adecuada es su potencia, si existe. La potencia de la señal es el promedio de tiempo de
% su energía (promediada durante todo el intervalo de tiempo desde −∞ hasta ∞). Para señales periódicas, el tiempo
% el promedio sólo debe realizarse durante un período en vista de la repetición periódica de la señal.
% La potencia de la señal también es igual al valor medio cuadrático de la señal (promediado durante todo el tiempo).
% intervalo de t = −∞ a ∞).
% Las señales se pueden clasificar de varias formas.
%
% * 1. Se especifica una señal de tiempo continuo para un continuo de valores de la variable independiente.
% (como el tiempo t). Una señal de tiempo discreto se especifica sólo en un conjunto finito o contable de
% instantes de tiempo.
% * 2. Una señal analógica es una señal cuya amplitud puede tomar cualquier valor en un continuo. En
% Por otro lado, una señal cuyas amplitudes sólo pueden tomar un número finito de valores es una
% señal digital. Los términos tiempo discreto y tiempo continuo califican la naturaleza de una señal.
% a lo largo del eje del tiempo (eje horizontal). Los términos analógico y digital, por otro lado,
% calificar la naturaleza de la amplitud de la señal (eje vertical).
% * 3. Una señal periódica x(t) se define por el hecho de que x(t) = x(t +T0) para algún T0. El mas pequeño
% El valor positivo de T0 para el cual se satisface esta relación se denomina período fundamental.
% Una señal periódica permanece sin cambios cuando se desplaza un múltiplo entero de su período.
% Una señal periódica x(t) puede generarse mediante una extensión periódica de cualquier segmento contiguo
% de x(t) de duración T0. Finalmente, una señal periódica, por definición, debe existir en todo el
% intervalo de tiempo −∞ < t < ∞. Una señal es aperiódica si no es periódica.
% * 4. Una señal eterna comienza en t = −∞ y continúa para siempre hasta t = ∞. Por lo tanto, periódico
% Las señales son señales eternas. Una señal causal es una señal que es cero para t < 0.
% * 5. Una señal con energía finita es una señal de energía. De manera similar, una señal con finito y distinto de cero
% La potencia (valor cuadrático medio) es una señal de potencia. Una señal puede ser una señal de energía o
% una señal de potencia, pero no ambas. Sin embargo, hay señales que no son ni energía ni potencia.
% señales.
% * 6. Una señal cuya descripción física se conoce completamente en forma matemática o gráfica.
% La forma es una señal determinista. Una señal aleatoria se conoce sólo en términos de su probabilidad.
% descripción como valor medio o valor cuadrático medio, en lugar de por su valor matemático o
% forma gráfica.
%
% Una señal x(t) retrasada T segundos (desplazada a la derecha) se puede expresar como x(t − T); en el otro
% Por otro lado, x(t) avanzado por T (desplazado a la izquierda) es x(t + T). Una señal x(t) comprimida en el tiempo por un factor
% a(a > 1) se expresa como x(at); por otro lado, la misma señal ampliada en el tiempo por el factor a(a > 1)
% es x(t/a). La señal x(t) cuando se invierte el tiempo se puede expresar como x(−t).
% La función de paso unitario u(t) es muy útil para representar señales causales y señales con
% diferentes descripciones matemáticas en diferentes intervalos.
% En la definición clásica (Dirac), la función de impulso unitario δ(t) se caracteriza por un área unitaria
% y se concentra en un solo instante t = 0. La función de impulso tiene un muestreo (o tamizado)
% propiedad, que establece que el área bajo el producto de una función con un impulso unitario es igual a
% el valor de esa función en el instante en que se localiza el impulso (suponiendo que la función
% ser continuo en el lugar del impulso). En el enfoque moderno, la función de impulso se considera como
% una función generalizada y está definida por la propiedad de muestreo.
% La función exponencial est, donde s es compleja, abarca una gran clase de señales que
% incluye una constante, una exponencial monótona, una sinusoide y una sinusoide que varía exponencialmente.
% Una señal real que es simétrica con respecto al eje vertical (t = 0) es una función par del tiempo,
% y una señal real que es antisimétrica con respecto al eje vertical es una función impar del tiempo. El
% El producto de una función par y una función impar es una función impar. Sin embargo, el producto de una
% función par y una función par o una función impar y una función impar es una función par.
% El área bajo una función impar desde t = −a hasta a es siempre cero independientemente del valor de a. En
% por otro lado, el área bajo una función par desde t = −a hasta a es dos veces el área bajo la
% misma función desde t = 0 hasta a (o desde t = −a hasta 0). Cada señal se puede expresar como una suma de
% funciones pares e impares del tiempo.
% Un sistema procesa señales de entrada para producir señales de salida (respuesta). La entrada es la causa,
% y el resultado es su efecto. En general, la producción se ve afectada por dos causas: las condiciones internas
% del sistema (como las condiciones iniciales) y la entrada externa.
% Los sistemas se pueden clasificar de varias maneras.
%
% * 1. Los sistemas lineales se caracterizan por la propiedad de linealidad, que implica superposición; si
% varias causas (como diversas entradas y condiciones iniciales) actúan sobre un sistema lineal,
% El resultado total (respuesta) es la suma de las respuestas de cada causa, suponiendo que todas
% las causas restantes están ausentes. Un sistema es no lineal si no se cumple la superposición.
% * 2. En sistemas invariantes en el tiempo, los parámetros del sistema no cambian con el tiempo. Los parámetros de
% Los sistemas de parámetros variables en el tiempo cambian con el tiempo.
% * 3. Para sistemas sin memoria (o instantáneos), la respuesta del sistema en cualquier instante t depende
% sólo en el valor de la entrada en t. Para sistemas con memoria (también conocidos como sistemas diámicos), la respuesta del sistema en cualquier instante t depende no sólo del valor presente de la
% entrada, sino también en los valores pasados de la entrada (valores antes de t).
% * 4. Por el contrario, si la respuesta del sistema en t también depende de los valores futuros de la entrada (valores de
% entrada más allá de t), el sistema es no causal. En los sistemas causales, la respuesta no depende
% sobre los valores futuros de la entrada. Debido a la dependencia de la respuesta del futuro.
% valores de entrada, el efecto (respuesta) de los sistemas no causales ocurre antes que la causa. Cuando
% la variable independiente es el tiempo (sistemas temporales), los sistemas no causales son proféticos
% sistemas y, por lo tanto, irrealizables, aunque una aproximación cercana es posible con algunos
% retraso en la respuesta. Sistemas no causales con variables independientes distintas del tiempo.
% (por ejemplo, el espacio) son realizables.
% * 5. Los sistemas cuyas entradas y salidas son señales de tiempo continuo son señales de tiempo continuo.
% sistemas; Los sistemas cuyas entradas y salidas son señales de tiempo discreto son señales de tiempo discreto.
% sistemas. Si se muestrea una señal de tiempo continuo, la señal resultante es una señal de tiempo discreto.
% señal. Podemos procesar una señal de tiempo continuo procesando las muestras de la señal.
% con un sistema de tiempo discreto.
% * 6. Son sistemas analógicos los sistemas cuyas entradas y salidas sean señales analógicas; Esos que
% Las entradas y salidas son señales digitales, son sistemas digitales.
% * 7. Si podemos obtener la entrada x(t) a partir de la salida y(t) de un sistema S mediante alguna operación,
% Se dice que el sistema S es invertible. De lo contrario, el sistema no es invertible.
% * 8. Un sistema es estable si una entrada limitada produce una salida limitada. Esto define lo externo.
% Estabilidad porque se puede determinar a partir de mediciones en los terminales externos.
% del sistema. La estabilidad externa también se conoce como estabilidad en el BIBO.
% (entrada limitada/salida limitada). La estabilidad interna, que se analiza más adelante en el cap. 2, es
% medido en términos del comportamiento interno del sistema.
% El modelo del sistema derivado del conocimiento de la estructura interna del sistema es su
% descripción interna. Por el contrario, una descripción externa es una representación de un sistema tal como se ve.
% desde sus terminales de entrada y salida; se puede obtener aplicando una entrada conocida y midiendo
% la salida resultante. En la mayoría de los sistemas prácticos, una descripción externa de un sistema es tan
% obtenido es equivalente a su descripción interna. A veces, sin embargo, la descripción externa no logra
% describir adecuadamente el sistema. Tal es el caso de los llamados incontrolables o inobservables.
% sistemas.
% Un sistema también puede describirse en términos de cierto conjunto de variables clave llamadas variables de estado.
% En esta descripción, un sistema de enésimo orden se puede caracterizar por un conjunto de N sistemas simultáneos de primer orden.
% ecuaciones diferenciales en N variables de estado. Las ecuaciones de estado de un sistema representan una ecuación interna que describe ese sistema.
%

%% Problema 2
% 1.2-2 For the signal x(t) illustrated in Fig. P1.2-2,sketch
%
% * (a) x(t −4)
% * (b) x(t/1.5)
% * (c) x(−t)
% * (d) x(2t −4)
% * (e) x(2−t)
%
% Generando la función original
% Iniciamos recreando la señal, mostrada en la grafica que muestra "Lathi" Hacemos anonima la funcion y la guardamos en la varibale "y". Continuamente proponemos un intervalo adecuado y se pueda representar en la grafica correctamente.
%%
sympref('HeavisideAtOrigin',0);
y = @(t) (-t.*(heaviside(t+4)) + 2*t.*(heaviside(t))).*heaviside(-t+2);
t= -7:0.01:7;
plot(t,y(t)); xlabel('t'); ylabel('y(t)');
title('Fig. P1.2-2');

%% a) x(t-4)
% Como se observa en el inciso "A", podemos ver que se trata de una traslacion horizontal en 4 unidades. Por lo que simplemente realizamos la traslacion y la graficamos.
%%
A=y(t-4);
plot(t,A); xlabel('t'); ylabel('y(t-4)');
title('Figura A');

%% b) x(t/1.5)
% En el inciso "B" podemos percatarnos que ahora se trata de una division entre la variable "t", pero recordando un poco sobre el comportamiento de las funciones, tenemos que al dividir la variable de la funcion, se ancha la amplitud de manera horizontal sin modificar la altura de la señal original. Por lo que:
%%
B=y(t./1.5);
plot(t,B); xlabel('t'); ylabel('y(t/1.5');
title('Figura B');
%%
% Como se determino inicialmente, la funcion se ampli de manera horizontal en un valor de 1.5
%% c)x(−t)
% En el inciso "C" se muestra la funcion original, con la unica diferencia que tiene un signo negativo en la "x", esto nos representa una inversion horizontal de la funcion original, es decir, realiza un efecto espejo.
%%
C=y(-t);
plot(t,C); xlabel('t'); ylabel('y(-t)');
title('Figura C');
%%
% Tal y como se argumento es una inversion horizontal de la funcion original.
%% d) x(2t −4)
% Podemos ver que ahora se presentan dos cambios, una compresion y una traslacion, ambas de manera horizontal, obsevando se deduce que se comprime entre dos, respecto a la funcion original y ademas se traslada 4 unidades.
%%
D= y(2.*t-4);
plot(t,D); xlabel('t'); ylabel('y(2t-4)');
title('Figura D');
%% e) x(2−t)
% En el inciso "E" se muestra una "t" negativa y un 2 positivo, reordenando vemos x(-t+2), por lo cual se trata de una inversion y una traslacion, ambas horizontales, la traslacion es de dos unidades.
E=y(2-t);
plot(t,E); xlabel('t'); ylabel('y(2-t)');
title('Figura E');

%% Problema 3
% Proporcionar código MATLAB y resultados que tracen la porción impar xo(t) de la función x(t) = 2−t cos(2πt)u(t−π) en un intervalo de longitud adecuada utilizando un número adecuado de puntos.
%
% Para empezar, observamos que x(t) comienza en t = π. Dado que 2−t decae a menos de 1/100 de su resistencia original en 7 segundos, es suficiente representar x(t) en t = 10.
%%
% Dado que xo(t) incluye x(t) y su reflexión, a el rango de tiempo adecuado para nuestra gráfica es −10 ≤ t ≤ 10. 
%%
 u = @(t) 1.0*(t>=0); t = -10:1/20:10;
%%
% Dado que cos(2πt) oscila un ciclo por segundo, a una densidad de trama de 20 puntos por segundo es suficiente para una trama de calidad razonable.
%%
x = @(t) 2.^(-t).*cos(2*pi*t).*u(t-pi); xo = @(t) (x(t)-x(-t))/2;
%%
% Usamos la funcion plot con las variables previamente designadas y graficamos:
%%
 plot(t,xo(t),'k-'); xlabel('t'); ylabel('x_o(t)'); grid on;
 axis([-10 10 -1/20 1/20]); set(gca,'xtick',[-10 -pi 0 pi 10]);
%%
%% Problema 4 
%  Construye la grafica de
%
% $$x(t) = \sum_{k=1}^{10} cos(2\pi k t)$$
%
% para cuatro rangos (figura 2x2). Los ejes deben mostrarse en el origen además de la edición de su preferencia.
%
% A continuación se muestra la grafica:

%%
% 
% <<grafica.PNG>>
% 

 


%% Problema 5
% Resuelve el problema 1.11-3, agrega como inciso (e) la gráfica de 
% $x(t)$ para $t\in[-10,10]$ 

%% Problema 6
%%
% El resultado de esta aplicacion se puede observar en la siguiente imagen, en la cual se enseña como al darle una funcion "t", la grafica y selecciona los intervalos dados, en este caso entre -5 y 2. Donde se puede mostrar que corta a la funcion justo en esos valores de t
%%
% 
% <<Problema_6.PNG>>
%%
% Primeramente para explicar, las lineas de codigo tenemos que mostrar los componentes que utilizamos, en primer lugar usamos Axes (Para graficar), Edit Field text(Para ingresar las funciones), Edit Field Numerico (Para ingresar los limites de la funcion y variaciones max y min), Push Button (Para que inicie el proceso de graficacion), Area Text (mostrar raices).
%%
% 
% <<Problema_6_b.PNG>>
% 
%%
% Desenglozando el codigo vamos al apartado de callbacks del push button para que todo gire en torno al presionarlo. Primero vamos a leer los caracteres que tiene la funcion que ingresa el usuario, especificamente los valores de cada uno. Despues tenemos que convertir esa funcion en una variable simbolica, llamando a las funciones que nos proporciona MATLAB. Al final describimos la variable simbolica en un vector, despues calulamos las raices del polinomio Y ese valor de las raices las enviamos al area de texto (esto sirve para identificar partes reales de imaginarias). Siguiendo tenemos que programar la seccion para establecer limites de maximos y minimos en valores de x & y para poder tener un campo especifico de la funcion, tomados en intervalos. Asi mismo, damos en el intervalo de integracion de 100 puntos, para que en la grafica se vea fluida la funcion ya graficada. Para graficar haremos uso de la funcion plot, donde se debe especificar que se dibuja en el panel de la grafica. Despues colocamos dos if's en el cual se define los valores de los ejes en x&y, recordando que se reciben valores infinitos, y con ayuda del if, se calcularan automaticamente, con ayuda de los valores maximos de t y l.
%%
% 
% <<Problema_6_a.PNG>>
% 






%% REFERENCIAS
% * 1. Papoulis, A., La integral de Fourier y sus aplicaciones. McGraw-Hill, Nueva York, 1962.
% * 2. Mason, S. J., Circuitos, señales y sistemas electrónicos. Wiley, Nueva York, 1960.
% * 3. Kailath, T., Sistemas lineales. Prentice-Hall, Englewood Cliffs, Nueva Jersey, 1980.
% * 4. Lathi, B. P., Señales y sistemas. Prensa de Berkeley-Cambridge, Carmichael, CA, 1987

##### SOURCE END #####
-->
</body>
</html>
